xquery version "1.0" encoding "UTF-8";

(: This file was generated on Wed Feb 15, 2012 12:49 by REx v5.12 which is Copyright (c) 1979-2012 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: relax-ng-compact.ebnf -xquery -backtrack -ll 2 -faster -tree -trace :)

(:~
 : The parser that was generated for the relax-ng-compact grammar.
 :)
module namespace p = "relaxng-compact";

declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  52, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 5, 6, 4, 4, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 4, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 4, 4, 17, 18, 19, 4, 20, 21, 21, 21, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 4, 21, 4, 25, 26, 27,
  28, 29, 30, 31, 32, 33, 21, 34, 35, 36, 37, 38, 39, 21, 40, 41, 42, 43, 44, 45, 46, 47, 21, 48, 49, 50, 51, 4
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 979, 993, 1001, 1279, 1279, 1012, 1031,
  1039, 1047, 1055, 1287, 1287, 1287, 1287, 1287, 1287, 1288, 1287, 1279, 1279, 1280, 1279, 1279, 1279, 1280, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1281, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1287, 1279, 1279, 1279, 1279, 1279, 1279, 1360, 1280, 1278, 1277, 1279, 1279, 1279, 1279,
  1279, 1280, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1283, 1020, 1279, 1279, 1279, 1279, 1208, 1023, 1279,
  1279, 1279, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1286, 1287, 1022, 1285, 1287, 985, 1287, 1287, 1287, 1287, 1287, 1278, 1279, 1279, 1284, 1123, 1133, 984, 1287,
  979, 985, 1123, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1362, 1279, 1280, 1142, 979, 1160, 1221, 979, 985,
  979, 979, 979, 979, 979, 979, 979, 979, 981, 1287, 1287, 1287, 985, 1287, 1287, 1287, 1385, 1256, 1279, 1279, 1276,
  1279, 1279, 1279, 1279, 1280, 1280, 1395, 1277, 1279, 1283, 1287, 1278, 1077, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1278, 1077, 1279, 1279, 1279, 1279, 1086, 1287, 1279, 1279, 1279, 1279, 1279, 1279, 1103, 1112, 1279,
  1279, 1279, 1104, 1281, 1285, 1420, 1279, 1279, 1279, 1279, 1279, 1279, 1179, 979, 981, 1222, 1279, 1165, 979, 1287,
  1287, 1420, 1103, 1361, 1279, 1279, 1277, 1206, 1217, 1151, 1168, 1288, 1232, 1165, 979, 1285, 1287, 1243, 1266, 1361,
  1279, 1279, 1277, 1069, 1217, 1171, 1168, 1287, 1254, 1289, 979, 1264, 1287, 1420, 1255, 1276, 1279, 1279, 1277, 1274,
  1179, 1326, 1095, 1287, 1287, 1190, 979, 1287, 1287, 1420, 1103, 1361, 1279, 1279, 1277, 1358, 1179, 1223, 1168, 1289,
  1232, 1115, 979, 1287, 1287, 1198, 1298, 1314, 1310, 1209, 1298, 1003, 1115, 1224, 1221, 1288, 1287, 1288, 979, 1287,
  1287, 1420, 1077, 1277, 1279, 1279, 1277, 1078, 1115, 1327, 1221, 1290, 1287, 1115, 979, 1287, 1287, 1198, 1077, 1277,
  1279, 1279, 1277, 1078, 1115, 1327, 1221, 1290, 1409, 1115, 979, 1287, 1287, 1198, 1077, 1277, 1279, 1279, 1277, 1279,
  1115, 1152, 1221, 1288, 1287, 1115, 979, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1287, 1287, 1287, 1279, 1279, 1279, 1279, 1281, 1287, 1279, 1279, 1279, 1279, 1280, 1287,
  1278, 1279, 1279, 1279, 1279, 1280, 1322, 984, 1125, 980, 979, 985, 1287, 1287, 1287, 1287, 1235, 1335, 1021, 1278,
  1345, 1355, 1322, 1185, 1370, 981, 979, 985, 1287, 1287, 1287, 1287, 1409, 1302, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1284, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1274, 1068, 1284, 1287, 1287, 1287, 1287, 1393, 1286, 1393, 1208, 1018, 1347, 1207, 1234, 1287, 1287, 1287,
  1287, 1409, 1287, 1337, 1408, 1312, 1284, 1287, 1287, 1287, 1287, 1404, 1286, 1406, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1283, 1279, 1279, 1279, 1279,
  1279, 1279, 1279, 1279, 1279, 1279, 1279, 1285, 1279, 1279, 1281, 1281, 1279, 1279, 1279, 1279, 1281, 1281, 1279,
  1396, 1279, 1279, 1279, 1281, 1279, 1279, 1279, 1279, 1279, 1279, 1077, 1004, 1246, 1282, 1104, 1283, 1279, 1282,
  1246, 1282, 1062, 1287, 1287, 1287, 1278, 1134, 1150, 1287, 1278, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1282, 1195, 1278, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1417, 1020, 1279, 1279, 1279,
  1279, 1282, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 979, 982, 1383, 1287, 1287,
  1287, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279, 1279,
  1279, 1279, 1283, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 985, 979, 985, 972, 1375, 1279,
  1278, 1279, 1279, 1279, 1285, 978, 979, 1327, 983, 1326, 978, 979, 981, 978, 1383, 1287, 1287, 1287, 1287, 1287, 1287,
  1287, 1287, 1278, 1279, 1279, 1279, 1280, 1406, 1278, 1279, 1279, 1279, 1280, 1287, 978, 979, 1148, 979, 979, 1091,
  1380, 1287, 1279, 1279, 1279, 1284, 1284, 1287, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 1, 4, 5, 6, 4, 4,
  7, 8, 9, 10, 11, 12, 13, 14, 15, 4, 4, 4, 4, 4, 15, 4, 15, 15, 15, 15, 15, 15, 15, 15, 4, 4, 4, 4, 4, 4, 15, 15, 16,
  4, 4, 17, 18, 19, 4, 20, 21, 21, 21, 21, 21, 21, 4, 21, 4, 21, 21, 21, 22, 23, 24, 4, 21, 4, 4, 4, 4, 4, 21, 21, 21,
  21, 21, 21, 4, 25, 26, 27, 28, 29, 30, 31, 32, 33, 21, 34, 35, 36, 37, 38, 39, 21, 40, 41, 42, 43, 44, 45, 46, 47, 21,
  48, 49, 50, 51, 4, 4, 4, 4, 4, 15, 4, 21, 4, 21, 21, 4, 21, 21, 4, 21, 21, 21, 21, 21, 4, 21, 21, 21, 21, 21, 4, 15,
  15, 15, 15, 4, 15, 15, 15, 4, 15, 15, 15, 4, 4, 21, 21, 21, 21, 21, 4, 4, 21, 21, 21, 4, 4, 21, 21, 4, 4, 4, 4, 15,
  15, 15, 21, 21, 21, 21, 21, 21, 21, 15, 15, 21, 21, 21, 15, 15, 15, 15, 15, 15, 21, 21, 21, 21, 4, 21, 15, 15, 4, 15,
  15, 15, 15, 15, 4, 4, 15, 15, 15, 15, 15, 15, 15, 21, 21, 15, 15, 4, 4, 15, 15, 15, 4, 4, 4, 4, 15, 21, 21, 4, 4, 15,
  21, 15, 15, 4, 15, 15, 21, 4, 4, 4, 4, 4, 15, 15, 4, 4, 15, 15, 4, 21, 21, 21, 21, 4, 21, 4, 4, 4, 21, 21, 4, 4, 4,
  21, 21, 4, 4, 15, 4, 15, 15, 15, 15, 4, 4, 4, 15, 15, 4, 4, 4, 4, 21, 21, 4, 21, 4, 4, 21, 4, 4, 15, 4, 4, 21, 21, 21,
  4, 21, 21, 4, 21, 21, 21, 21, 4, 21, 4, 21, 21, 15, 15, 21, 21, 21, 4, 4, 4, 4, 21, 21, 4, 21, 21, 4, 21, 21, 21, 21,
  21, 21, 21, 21, 4, 4, 4, 4, 4, 4, 4, 4, 15, 15, 4, 21, 21, 21, 4, 4, 4, 21, 21, 4, 4, 21, 4, 4, 21, 21, 4, 21, 4, 21,
  21, 21, 21, 4, 4, 21, 15, 21, 21, 15, 15, 15, 15, 15, 15, 4, 15, 15, 21, 4, 21, 4, 4, 21, 4, 4, 21, 21, 4, 21, 21, 21,
  4, 21, 4, 21, 4, 21, 4, 4, 21, 21, 4, 21, 21, 4, 4, 21, 21, 21, 21, 21, 4, 21, 21, 21, 21, 21, 4, 15, 4, 4, 4, 4, 15,
  15, 4, 15, 4, 4, 4, 4, 4, 4, 21, 15, 4, 4, 4, 4, 21, 4, 21, 4, 21, 4, 21, 4, 4, 4, 21, 4, 4, 4, 4, 4, 4, 4, 21, 4, 21,
  21, 21, 4, 15, 15, 15, 4, 21, 21, 21
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 4, 4
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 1027, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 2073, 2074, 2075, 2076,
  2077, 2078, 31, 2080, 33, 2082, 2083, 2084, 37, 2086, 39, 40, 41, 42, 43, 44, 45, 46, 2095, 48, 49, 50, 2099
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3392, 3448, 3460, 3476, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345,
  4937, 3722, 3735, 3731, 4415, 4926, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052,
  4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3392, 3448, 3460, 3543, 3727,
  4403, 4937, 4937, 4064, 3736, 3733, 4281, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812,
  3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3392, 3448, 3460, 3476, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415,
  4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158,
  4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3570, 3727, 4730, 4937, 4937, 3582, 3736,
  3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755,
  4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3623, 4193, 3609,
  3657, 3727, 4730, 4937, 4937, 3681, 3736, 3733, 4345, 4937, 3722, 4350, 3731, 4415, 4743, 4937, 4937, 4936, 3715,
  3729, 4812, 3950, 3693, 4699, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3752, 3821, 3836, 3849, 3727, 4913, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735,
  3731, 4415, 3937, 4937, 4937, 4936, 4069, 3729, 5093, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502,
  3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3886, 3900, 3924, 3727, 4730, 4937, 4937,
  3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105,
  3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3992,
  4314, 3978, 4039, 3727, 4730, 4937, 4937, 3669, 3736, 3733, 4345, 4937, 3722, 4420, 3731, 4415, 4743, 4937, 4937,
  4936, 4089, 3729, 4812, 3950, 3693, 3962, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554,
  3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3908, 4119, 4132, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937,
  3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799,
  3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 10034, 4173, 4187, 4209, 3727, 4730,
  4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950,
  3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 10040, 4372, 4251, 4266, 3727, 4730, 4937, 4937, 3582, 3736, 4073, 4345, 4937, 10005, 3735, 3731, 4415, 4743,
  4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223,
  9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 4442, 4308, 4330, 3727, 4730, 4937, 4937, 3582, 3736, 3733,
  4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785,
  4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5032, 4366, 4388,
  3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729,
  4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 5001, 4990, 4436, 4458, 5850, 4483, 4563, 7581, 4532, 7519, 5689, 4557, 4568, 5518, 7603, 3641,
  5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490,
  3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 4458, 5850, 4483, 4563, 7581, 4532,
  7519, 5689, 4557, 4568, 5518, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845,
  5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3570, 4101, 4647, 4590, 4292, 4157, 3699, 5358, 5353, 4595, 3593, 4616, 3731, 4584, 4660, 4590, 4287, 4611,
  4069, 4103, 4632, 4687, 3861, 4715, 4096, 4882, 4771, 4145, 4840, 4671, 4869, 3870, 4853, 4235, 4898, 5417, 4953,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 5010, 4978, 5008, 3570, 3727, 5063, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722,
  3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486,
  3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 6200, 5026, 5048, 3727, 5078, 4937,
  4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693,
  5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 5127, 5121, 5143, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937,
  4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983,
  3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581, 4532, 5606, 5689, 4557,
  4568, 5490, 7603, 8664, 5879, 4496, 9265, 6611, 7469, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582,
  6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850,
  4483, 4563, 7581, 4532, 5606, 5689, 4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549,
  4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 5268, 5277, 5293, 5307, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415,
  4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158,
  4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5323, 5374, 5386, 5338, 3727, 4730, 4937, 4937, 3582, 3736,
  3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755,
  4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 9916,
  5402, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069,
  3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 5433, 5449, 5463, 5479, 5534, 5572, 6370, 5622, 5649, 5675, 8041, 5705, 5734, 9650, 5762,
  3641, 5778, 4496, 9054, 6757, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 9098, 3805, 6439, 6617, 8731, 5798, 5994,
  5827, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581,
  4532, 5606, 5689, 4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 8555,
  6548, 3793, 6750, 6575, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174,
  5231, 6413, 6541, 5850, 4483, 4563, 7581, 4532, 5868, 8706, 5895, 9535, 5490, 5919, 3641, 5686, 4496, 4563, 8300,
  9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 8769, 5958, 4541, 5984, 9415,
  9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 6010, 6026, 6040, 6056, 5850, 4483, 4563, 7581, 4532, 5606, 5689, 4557, 4568,
  5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 6079, 6317, 6174, 3432, 7580, 6118, 8414, 9148, 4567, 9620, 6495,
  4506, 8297, 6490, 3422, 8301, 5500, 6159, 6190, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 6216, 6232, 6246, 6262, 5932, 6289,
  5903, 7137, 6345, 5606, 6386, 6429, 9577, 6273, 7603, 7498, 7385, 8508, 6455, 6471, 6511, 3637, 5852, 9566, 8453,
  7873, 7897, 5845, 5243, 4567, 7582, 9466, 8443, 8297, 7148, 6133, 6527, 9660, 6564, 9795, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581, 6599, 9120, 5689, 4557, 6854, 9356, 7603, 3641, 5686, 4496,
  4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422, 8301,
  5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 6633, 6649, 6663, 6679, 5850, 4483, 4563, 7581, 4532, 5606, 5689,
  4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 6862, 7853, 5600,
  8762, 6703, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541,
  5850, 4483, 4563, 7581, 4532, 6729, 9384, 6773, 7717, 5490, 6819, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852,
  5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 6878, 6894, 6908, 6924, 5746, 6940, 5215, 6984, 4532, 5606, 5689, 4557, 4568, 5490, 7603, 7041,
  5686, 7000, 7260, 4467, 9196, 7036, 9048, 9743, 8182, 6793, 7897, 4016, 7250, 7560, 7222, 6495, 4506, 8297, 6490,
  3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581, 4532,
  6063, 5782, 7057, 9860, 7459, 6803, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845,
  5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 7079, 7095,
  7109, 7125, 8172, 4483, 7164, 8230, 4532, 5606, 5689, 4557, 4568, 5490, 7603, 5839, 6740, 5202, 4563, 8300, 6484,
  3407, 4023, 5549, 7203, 7220, 9329, 7238, 8376, 7284, 7310, 7336, 4506, 8297, 8803, 5189, 9615, 7362, 9415, 9795,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 7401, 7417, 7431, 7447, 9222, 4483, 7485, 8628, 4532, 7374, 5252, 4557, 7204, 8948,
  9018, 7514, 6843, 5811, 7535, 7576, 7598, 7619, 6359, 8907, 5942, 5659, 7897, 5845, 5243, 4567, 7582, 6495, 4506,
  8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 7645, 7661, 7675, 7691, 6713, 7733, 5556,
  7924, 4532, 5606, 5689, 4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 4006, 7749, 7765, 7788, 8072,
  5633, 8494, 6329, 6143, 9426, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  5174, 5231, 6413, 6541, 7810, 7840, 8108, 7889, 7913, 5606, 5689, 4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563,
  8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 8251, 9712, 7268, 7320, 3422, 8301, 5500,
  9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 7940, 7956, 7970, 7986, 5850, 4483, 4563, 7581, 8013, 5606, 8057, 8097,
  9159, 9170, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 7629, 8135, 5968, 8796,
  8162, 8208, 5586, 8246, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 9085, 7346,
  4483, 6303, 7997, 4532, 8192, 7772, 8267, 8294, 8317, 8958, 9865, 8343, 8362, 7063, 9445, 6583, 8402, 7549, 8430,
  8278, 9587, 8479, 5845, 5243, 4567, 7582, 8081, 6954, 5510, 8534, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 8571, 8587, 8601, 8617, 5850, 4483, 4563, 7581, 4532, 9496, 8146, 8644, 9270, 5490, 8680, 3641, 5686,
  4496, 4563, 8300, 9193, 3767, 8028, 5549, 4567, 8722, 8747, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422,
  8301, 7187, 8785, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 8819, 8835, 8849, 8865, 9300, 8892, 8937, 6092, 8974, 9831,
  6968, 8990, 8219, 9006, 9034, 9690, 9507, 5718, 7824, 9783, 9070, 9114, 3781, 9136, 6783, 7294, 8327, 5845, 5243,
  8658, 9186, 9212, 8386, 9238, 9286, 6401, 9316, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413,
  6541, 5850, 4483, 4563, 7581, 4532, 5606, 5689, 4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 9345,
  8694, 9372, 7863, 7020, 9400, 5845, 5243, 4567, 7582, 6102, 4516, 9442, 9461, 3422, 8301, 5500, 9415, 9795, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581, 9482, 7794, 8346, 9523, 4568, 8119, 7603,
  3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297,
  6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581,
  4532, 5606, 5689, 4557, 4568, 5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 3637, 5852, 5549, 4567, 7580, 7897,
  5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490, 9551, 6687, 9603, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 5174,
  5231, 6413, 9636, 9701, 4483, 9676, 8876, 4532, 6832, 9753, 9728, 8921, 7177, 9769, 3641, 5686, 4496, 4563, 8300,
  9193, 3637, 5852, 5549, 4567, 7580, 7897, 5845, 5243, 4567, 7582, 6495, 4506, 8297, 6490, 3422, 8301, 5500, 9415,
  9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 5174, 5231, 6413, 6541, 5850, 4483, 4563, 7581, 4532, 5606, 5689, 4557, 4568,
  5490, 7603, 3641, 5686, 4496, 4563, 8300, 9193, 9820, 7705, 9253, 8518, 8463, 7897, 9847, 5243, 7010, 8546, 6495,
  4506, 8297, 6490, 3422, 8301, 5500, 9415, 9795, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3527, 9881, 9910, 9894, 3727, 4730,
  4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950,
  3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 9932, 9946, 9968, 3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743,
  4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223,
  9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 9952, 9804, 10021, 10056, 3727, 4730, 4937, 4937, 3582, 3736, 3733,
  4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 5105, 3722, 4755, 4785,
  4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 10072,
  3727, 4730, 4937, 4937, 3582, 3736, 3733, 4345, 4937, 3722, 3735, 3731, 4415, 4743, 4937, 4937, 4936, 4069, 3729,
  4812, 3950, 3693, 5105, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503, 5158, 4223, 9983, 3554, 3519, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 4962, 3727, 4403, 4937, 4937, 4064, 3736, 3733, 9998, 4937, 3722, 3735, 3731,
  4415, 4743, 4937, 4937, 4936, 4069, 3729, 4812, 3950, 3693, 4824, 3722, 4755, 4785, 4052, 4799, 3486, 3502, 3503,
  5158, 4223, 9983, 3554, 3519, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906,
  3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 3906, 0, 0, 3126, 3126, 3126, 3126, 3126, 3126, 3126, 3126,
  3126, 0, 0, 0, 3126, 0, 0, 0, 0, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 440, 56, 0, 70, 70, 70, 70, 70, 0, 56, 70,
  70, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 56, 479, 0, 0, 3126, 3126, 0, 3126, 3126, 3126, 3126, 3126,
  3126, 3126, 3126, 3126, 3126, 3126, 0, 3126, 3126, 0, 3126, 3126, 3126, 3126, 3126, 3126, 3126, 3126, 3126, 3126,
  3126, 133, 135, 3126, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 104448, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 102400, 104448, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  102400, 104448, 69632, 69632, 69632, 69632, 100352, 88064, 89088, 100352, 69632, 101376, 101376, 101376, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 41984, 0, 0, 0, 0, 0, 0, 3126, 3126, 3126, 0, 0, 3126, 0, 69632, 0, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 94208, 69632, 69632, 100352, 88064, 69632, 88064, 89088, 100352, 69632, 89088, 0, 0, 0, 133, 135, 0,
  3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 133, 0, 135, 0, 3209, 69632, 69632, 69632, 69632,
  69632, 69632, 69632, 69788, 69788, 69788, 69788, 0, 69850, 69850, 69850, 69850, 69850, 69850, 52, 52, 0, 0, 0, 52, 0,
  0, 52, 0, 0, 52, 0, 0, 52, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 0, 56, 56, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 56, 56, 56, 56, 0, 52, 52, 52, 8326, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  133, 0, 8192, 237, 3209, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 8192, 236, 135, 0, 3209, 69632, 69632,
  69632, 69632, 69632, 69632, 69632, 105472, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 0, 0, 69788, 69788, 69788, 69788, 428, 429, 430, 430, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 0, 0, 69632, 69632, 69632, 69632, 0, 0, 3127, 3127, 3127, 3127, 3127, 3127, 3127, 3127, 3127, 0, 0, 0,
  3127, 0, 0, 0, 0, 56, 56, 56, 56, 56, 56, 56, 56, 56, 439, 56, 56, 0, 70, 444, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
  70, 0, 56, 86, 86, 56, 70, 70, 523, 70, 70, 70, 70, 0, 56, 86, 86, 56, 70, 70, 70, 70, 70, 70, 526, 0, 0, 3127, 3127,
  0, 3127, 3127, 3165, 3165, 3165, 3127, 3127, 3165, 3165, 3127, 3165, 3165, 3165, 3165, 0, 3165, 3127, 0, 3165, 3127,
  3127, 3127, 3165, 3127, 3165, 3165, 133, 135, 0, 0, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 105472,
  69632, 69788, 69788, 69788, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 102618, 104666,
  69632, 69632, 69632, 69632, 0, 89, 89, 0, 0, 89, 0, 0, 0, 0, 9216, 9305, 9216, 9216, 0, 9216, 9216, 9216, 0, 9216, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11264, 0, 0, 0, 9216, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 0, 91136, 69632, 0, 0, 69632, 375, 91136, 69632, 69632, 69632, 69632, 69632, 105472,
  69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 98304, 69632, 69632, 69632, 69632, 69632, 69632,
  105472, 69632, 236, 236, 0, 8192, 69632, 53, 53, 0, 0, 0, 53, 0, 0, 53, 0, 0, 53, 0, 0, 53, 0, 0, 0, 53, 0, 0, 0, 0,
  0, 0, 0, 0, 53, 0, 0, 0, 0, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 248, 56, 56, 56, 0, 70, 70, 70, 70, 70, 70,
  70, 70, 70, 70, 451, 70, 70, 53, 53, 53, 133, 8328, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 106496, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 93184, 69632, 69632, 69632, 69632, 0, 0, 0, 0, 0,
  69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 6144, 0, 69632, 429, 429,
  430, 431, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 69788, 69788, 69788,
  69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 11264, 0, 0, 0, 0, 0, 0, 0, 11264, 0, 0, 0, 0,
  11264, 11264, 11264, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 106496, 69788,
  69788, 69788, 69850, 69850, 69850, 69850, 93402, 69850, 69850, 69850, 69850, 133, 0, 135, 0, 3209, 69632, 69632,
  69632, 69632, 69632, 69632, 69632, 0, 0, 0, 12288, 0, 0, 12288, 0, 0, 0, 0, 0, 12288, 12288, 0, 12288, 12288, 12288,
  0, 12288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 52, 0, 0, 0, 12288, 133, 135, 0, 3209, 69632, 0, 69632, 69632,
  69632, 69632, 69632, 69632, 69632, 90112, 92160, 69632, 95232, 97280, 69632, 69632, 69632, 90112, 69632, 69632, 69632,
  90112, 92160, 69632, 95232, 97280, 69632, 69632, 69788, 90268, 69788, 69850, 69850, 90330, 92378, 0, 13312, 13312,
  13312, 0, 13312, 0, 0, 0, 0, 0, 0, 0, 13312, 0, 13312, 13312, 13312, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 0, 0, 69632, 282, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69788, 69788, 69788, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 0, 14336, 14336, 14336, 0, 14336,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 53, 0, 0, 0, 14336, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 0, 0, 69632, 7349, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 337, 339, 69632, 69632, 69632, 0, 15360, 15360, 15360, 0, 15360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13312, 13312, 0,
  13312, 0, 13312, 0, 0, 15360, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 0,
  69632, 69632, 0, 0, 0, 0, 0, 69632, 0, 0, 69632, 69632, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 338, 340, 69632, 69632, 69632, 0, 0, 16384, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  14336, 14336, 0, 14336, 0, 14336, 0, 0, 0, 133, 135, 0, 3209, 56, 0, 56, 56, 56, 56, 56, 56, 56, 404, 56, 56, 70, 70,
  70, 121, 121, 121, 70, 82, 0, 56, 56, 86, 86, 86, 0, 0, 56, 0, 3209, 70, 70, 70, 0, 56, 56, 86, 86, 56, 0, 70, 70, 70,
  70, 70, 70, 0, 86, 56, 70, 70, 70, 70, 70, 70, 70, 0, 86, 56, 70, 571, 70, 70, 70, 70, 70, 121, 121, 121, 121, 133, 0,
  135, 0, 3209, 56, 56, 56, 56, 56, 56, 56, 608, 56, 70, 70, 611, 121, 121, 121, 121, 56, 86, 86, 56, 7349, 70, 70, 70,
  70, 70, 70, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 0, 69788, 69788, 69788, 156, 69788, 69788,
  69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 69632, 91354, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850, 69850,
  69850, 69850, 0, 0, 69632, 69632, 69632, 69788, 0, 69632, 156, 156, 69632, 0, 69788, 69788, 69788, 69788, 69788,
  69788, 69788, 98460, 69788, 174, 0, 69632, 69632, 156, 156, 156, 0, 0, 69632, 0, 3209, 69788, 69788, 69788, 0, 91136,
  69632, 156, 156, 69632, 0, 91292, 69788, 69788, 69788, 69788, 69788, 69788, 0, 104604, 69632, 69788, 69788, 69788,
  69788, 69788, 69788, 102556, 69788, 69788, 69788, 105628, 69788, 69788, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 98304, 69632, 69632, 69632, 69632, 69632, 69632, 105472, 69632, 8192, 0, 237, 237, 69632, 69850, 69850,
  98522, 69850, 69850, 69850, 69850, 69850, 69850, 105690, 69850, 236, 236, 237, 237, 69632, 0, 0, 69632, 69632, 0, 0,
  0, 0, 0, 69632, 0, 3209, 69632, 69632, 69632, 0, 91136, 69632, 0, 0, 69632, 0, 91136, 69632, 69632, 69632, 69632,
  69632, 0, 103424, 0, 106496, 69632, 103424, 69632, 69632, 69632, 93184, 69632, 69632, 99484, 69788, 69788, 69788,
  106652, 69788, 69632, 69632, 69632, 69632, 93184, 69632, 69632, 69632, 99328, 69632, 69632, 69632, 106496, 69632,
  69632, 69632, 69632, 69632, 93184, 69632, 69632, 69632, 99328, 69632, 69632, 69632, 103424, 69632, 106496, 69632,
  69632, 69632, 69632, 69632, 69632, 69632, 0, 69632, 0, 0, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  98304, 69632, 69632, 69632, 69632, 69632, 69632, 105472, 69632, 0, 0, 0, 0, 69632, 99546, 69850, 69850, 69850, 103642,
  69850, 106714, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 69788, 69788, 69788, 69788, 69788, 97280, 96256,
  96412, 69788, 92316, 69788, 95388, 69788, 97436, 104604, 69788, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 102400, 104448, 69788, 69788, 69788, 69788, 0, 103424, 156, 106652, 69632, 103580, 69788, 69788, 69788,
  93340, 69788, 69788, 69850, 95450, 96474, 97498, 69850, 69850, 69632, 0, 69788, 69788, 94364, 69788, 69632, 69632,
  94208, 69632, 0, 0, 69632, 69632, 0, 0, 0, 0, 0, 69632, 0, 7349, 69632, 69632, 69632, 0, 91136, 69632, 0, 0, 69632,
  282, 91136, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 100508, 88282, 89306, 100570, 69850, 101532, 101376, 101594, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 0, 69632, 69632,
  69632, 69632, 69632, 69632, 69632, 0, 17408, 17408, 0, 0, 17408, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 16384, 0, 0,
  0, 16384, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 92, 92, 92, 0, 92,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15360, 15360, 15360, 15360, 0, 15360, 0, 0, 92, 133, 135, 0, 3209, 69632, 0, 69632,
  69632, 69632, 69632, 69632, 69632, 69632, 0, 0, 69632, 69632, 0, 0, 0, 10240, 44032, 69632, 0, 3209, 69632, 69632,
  69632, 0, 0, 69632, 69632, 0, 0, 0, 0, 0, 69632, 18432, 3209, 69632, 69632, 69632, 0, 69632, 0, 0, 69632, 7349, 69632,
  69632, 69632, 69632, 69632, 69632, 69632, 98304, 69632, 69632, 69632, 69632, 69632, 69632, 105472, 69632, 236, 236,
  237, 237, 69632, 0, 19456, 19456, 19456, 0, 19456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19456, 19456, 0, 19456, 0, 19456, 0,
  0, 19456, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 69632, 69632, 69632, 69632,
  69632, 97280, 96256, 96256, 69632, 92160, 69632, 95232, 69632, 97280, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 70, 82, 0, 0,
  56, 0, 70, 70, 261, 70, 70, 0, 56, 70, 70, 70, 603, 70, 70, 70, 0, 56, 56, 86, 86, 374, 0, 70, 70, 377, 70, 70, 70,
  190, 191, 70, 70, 70, 70, 70, 56, 176, 56, 56, 56, 206, 86, 0, 0, 0, 56, 0, 0, 70, 70, 70, 0, 0, 70, 70, 70, 70, 0,
  56, 86, 86, 56, 70, 70, 70, 70, 70, 70, 70, 270, 70, 70, 70, 70, 70, 0, 0, 56, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 20480, 0, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 0, 20480, 20480, 20480, 20480, 20480, 0, 20480, 0, 0,
  20480, 0, 0, 0, 20480, 0, 20480, 20480, 20480, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 57, 0, 0, 0, 57, 57, 57, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 156, 156, 69632, 7349, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788, 69788,
  69788, 69788, 69788, 69788, 0, 0, 69632, 0, 0, 0, 0, 57, 0, 0, 57, 57, 57, 0, 0, 57, 57, 57, 57, 57, 57, 57, 57, 57,
  57, 57, 57, 57, 57, 57, 57, 0, 0, 21504, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69788, 69788, 69850, 69850, 94426, 69850, 69850, 100352, 88220, 69788, 88064, 89088, 100352, 69632, 89244, 0, 0, 0,
  58, 0, 0, 0, 0, 0, 0, 0, 71, 82, 0, 0, 58, 86, 0, 0, 0, 58, 0, 0, 71, 71, 71, 0, 0, 71, 71, 97, 71, 71, 71, 107, 71,
  107, 97, 97, 107, 97, 97, 107, 122, 97, 122, 122, 122, 97, 133, 135, 0, 3209, 56, 56, 56, 139, 56, 56, 56, 56, 56, 70,
  70, 70, 70, 5377, 121, 121, 121, 121, 121, 121, 56, 0, 70, 70, 70, 70, 56, 56, 56, 56, 56, 582, 56, 56, 56, 56, 56,
  70, 70, 70, 70, 0, 121, 121, 121, 121, 121, 121, 149, 151, 56, 56, 155, 70, 70, 158, 70, 70, 70, 70, 70, 168, 170, 70,
  0, 56, 86, 86, 56, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70, 197, 56, 56, 56, 56, 205, 56, 70, 82, 0, 139, 56, 86, 86,
  86, 0, 0, 56, 0, 3209, 158, 70, 70, 56, 578, 56, 56, 56, 56, 56, 56, 56, 56, 56, 586, 70, 70, 70, 529, 70, 70, 56, 56,
  56, 56, 56, 56, 56, 56, 56, 56, 0, 5377, 70, 70, 70, 70, 56, 208, 210, 56, 56, 214, 216, 70, 121, 121, 220, 121, 121,
  121, 121, 121, 121, 500, 121, 502, 121, 503, 236, 236, 237, 237, 56, 230, 232, 121, 121, 133, 0, 135, 0, 3209, 56, 56,
  56, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 121, 494, 245, 56, 56, 56, 56, 56, 56, 253, 56, 56, 0, 5377,
  70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0, 0, 56, 278, 86, 86, 56, 7349, 70, 284, 70, 70, 70, 70,
  70, 290, 70, 70, 70, 0, 56, 56, 86, 86, 56, 0, 70, 70, 70, 70, 70, 380, 70, 273, 70, 70, 70, 56, 56, 56, 56, 56, 56,
  305, 56, 56, 56, 56, 0, 70, 70, 160, 70, 70, 70, 166, 167, 70, 70, 70, 121, 325, 121, 121, 121, 121, 121, 121, 333,
  121, 121, 0, 0, 56, 342, 343, 5377, 70, 357, 358, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 275, 0, 0, 56, 70,
  565, 70, 70, 566, 70, 0, 86, 56, 70, 70, 70, 573, 70, 70, 70, 0, 56, 56, 86, 86, 56, 0, 70, 70, 70, 70, 379, 70, 121,
  121, 121, 121, 593, 121, 121, 121, 597, 121, 121, 121, 56, 56, 56, 56, 56, 347, 56, 56, 56, 56, 56, 56, 56, 56, 56, 0,
  70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 56, 246, 56, 56, 56, 56, 56, 56, 56, 56, 0, 5377, 70, 70, 70, 70,
  70, 70, 70, 70, 70, 70, 70, 70, 70, 366, 70, 56, 86, 86, 281, 7349, 70, 70, 285, 70, 70, 70, 70, 70, 70, 70, 70, 195,
  70, 56, 200, 56, 56, 56, 56, 121, 121, 326, 121, 121, 121, 121, 121, 121, 121, 121, 0, 0, 56, 56, 56, 153, 0, 70, 70,
  159, 70, 70, 70, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 477, 56, 56, 56, 56, 600, 70, 70, 70, 516, 70, 0, 56, 70,
  70, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 56, 538, 121, 121, 121, 121, 615, 121, 56, 0, 70, 70, 70, 70,
  56, 56, 56, 56, 581, 56, 56, 584, 56, 56, 56, 70, 70, 588, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 72, 82, 0, 0, 84, 86, 0,
  0, 0, 84, 0, 0, 94, 94, 94, 0, 0, 94, 94, 72, 94, 94, 94, 108, 94, 108, 118, 94, 108, 118, 118, 108, 123, 118, 123,
  123, 123, 118, 133, 135, 0, 3209, 56, 56, 56, 56, 56, 56, 56, 56, 56, 255, 0, 5377, 70, 70, 70, 70, 0, 0, 0, 0, 56,
  56, 56, 56, 56, 56, 56, 56, 241, 56, 56, 56, 211, 56, 70, 70, 217, 121, 219, 121, 121, 121, 121, 121, 121, 121, 557,
  56, 56, 56, 56, 56, 56, 0, 563, 121, 121, 121, 497, 121, 121, 121, 121, 121, 121, 121, 236, 236, 237, 237, 56, 0, 70,
  601, 70, 70, 70, 0, 56, 70, 70, 70, 70, 70, 70, 70, 56, 56, 56, 534, 56, 535, 56, 56, 56, 56, 56, 70, 70, 121, 121,
  121, 121, 121, 0, 70, 630, 56, 56, 56, 631, 70, 0, 56, 86, 86, 56, 0, 70, 70, 70, 70, 70, 70, 70, 70, 465, 70, 121,
  121, 121, 632, 70, 56, 121, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 92, 92, 0, 0, 0, 92, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0,
  0, 73, 82, 0, 0, 60, 86, 0, 0, 0, 60, 0, 0, 73, 73, 73, 0, 0, 73, 73, 98, 73, 73, 73, 109, 73, 109, 98, 98, 109, 98,
  98, 109, 124, 98, 124, 124, 124, 98, 133, 135, 0, 3209, 56, 56, 56, 140, 56, 56, 56, 56, 56, 70, 70, 70, 70, 5377,
  121, 121, 121, 121, 322, 121, 172, 82, 0, 140, 56, 86, 86, 86, 0, 0, 56, 0, 3209, 159, 70, 70, 189, 70, 70, 70, 70,
  70, 70, 70, 56, 56, 56, 204, 56, 56, 0, 70, 70, 70, 70, 70, 70, 70, 70, 261, 70, 70, 70, 70, 0, 56, 86, 86, 56, 70,
  70, 70, 524, 70, 525, 70, 121, 121, 121, 234, 133, 0, 135, 0, 3209, 56, 56, 56, 56, 242, 56, 56, 0, 70, 70, 70, 70,
  70, 447, 70, 70, 70, 70, 70, 70, 70, 168, 193, 70, 70, 70, 56, 199, 56, 56, 56, 56, 262, 70, 70, 70, 70, 70, 70, 70,
  70, 70, 70, 70, 70, 0, 0, 56, 0, 516, 70, 70, 70, 70, 0, 56, 70, 602, 70, 70, 70, 70, 70, 56, 70, 56, 70, 70, 56, 70,
  70, 56, 121, 70, 121, 56, 86, 86, 56, 7349, 70, 70, 70, 70, 287, 70, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 536,
  56, 56, 56, 381, 70, 70, 384, 70, 386, 70, 70, 389, 390, 56, 56, 56, 56, 56, 396, 56, 398, 56, 400, 401, 56, 403, 56,
  56, 406, 70, 70, 409, 121, 121, 121, 121, 121, 417, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 56,
  56, 56, 56, 56, 56, 56, 0, 70, 121, 121, 121, 415, 121, 121, 418, 121, 420, 421, 121, 423, 121, 121, 121, 427, 56,
  606, 56, 56, 56, 56, 56, 56, 56, 610, 70, 70, 121, 613, 121, 121, 70, 133, 135, 0, 3209, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 0, 512, 70, 70, 70, 70, 70, 623, 70, 625, 626, 121, 121, 628, 629, 0, 70, 70, 56, 56, 56, 56, 70, 70, 70, 545,
  121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 424, 121, 121, 121, 121, 121, 121, 121, 133, 0, 135, 0,
  3209, 56, 56, 240, 56, 56, 56, 56, 56, 402, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 121, 550, 121, 121,
  0, 0, 0, 61, 0, 0, 0, 0, 0, 0, 0, 74, 82, 0, 0, 61, 86, 0, 0, 0, 61, 0, 0, 74, 74, 74, 0, 0, 74, 74, 99, 74, 74, 74,
  110, 74, 110, 99, 99, 110, 99, 99, 110, 125, 99, 125, 125, 125, 99, 133, 135, 0, 3209, 56, 56, 56, 56, 56, 56, 56, 56,
  56, 609, 70, 70, 70, 121, 121, 121, 121, 121, 121, 121, 121, 121, 556, 121, 56, 56, 56, 56, 56, 56, 56, 0, 70, 70, 70,
  70, 70, 165, 70, 70, 70, 70, 70, 56, 247, 56, 56, 56, 56, 56, 56, 56, 56, 0, 5377, 70, 70, 70, 70, 70, 70, 70, 70,
  362, 70, 70, 70, 70, 70, 70, 531, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 407, 408, 70, 121, 411, 412, 56, 86, 86,
  247, 7349, 70, 70, 267, 70, 70, 70, 70, 70, 70, 70, 70, 56, 472, 56, 56, 56, 56, 56, 56, 56, 56, 70, 70, 70, 488, 121,
  121, 121, 121, 121, 121, 121, 121, 121, 121, 336, 0, 0, 56, 56, 56, 121, 121, 327, 121, 121, 121, 121, 121, 121, 121,
  121, 0, 0, 56, 56, 56, 249, 56, 56, 56, 56, 248, 56, 0, 5377, 70, 70, 70, 70, 272, 70, 70, 361, 70, 70, 70, 70, 70,
  70, 70, 56, 56, 301, 56, 56, 56, 56, 56, 56, 56, 56, 241, 0, 70, 70, 70, 70, 70, 70, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0,
  75, 82, 83, 0, 62, 86, 0, 0, 0, 91, 0, 0, 75, 96, 96, 0, 0, 96, 96, 75, 96, 96, 106, 111, 96, 111, 106, 96, 111, 106,
  106, 111, 126, 96, 126, 126, 126, 106, 133, 135, 0, 3209, 56, 56, 56, 141, 56, 56, 56, 147, 148, 70, 82, 0, 176, 56,
  86, 86, 86, 0, 0, 56, 0, 3209, 182, 70, 70, 261, 70, 70, 70, 0, 86, 56, 70, 70, 70, 70, 574, 70, 70, 264, 70, 70, 70,
  70, 70, 271, 70, 70, 70, 70, 0, 0, 56, 207, 56, 56, 56, 56, 182, 70, 70, 121, 121, 222, 121, 121, 121, 228, 229, 70,
  368, 70, 0, 56, 56, 372, 86, 56, 0, 70, 70, 70, 70, 70, 70, 56, 532, 56, 56, 56, 56, 56, 56, 56, 56, 70, 486, 70, 121,
  121, 490, 121, 121, 121, 121, 0, 0, 0, 0, 432, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 353, 56, 0, 56, 86,
  280, 56, 7349, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 391, 56, 56, 56, 56, 56, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0,
  76, 82, 0, 0, 63, 86, 0, 0, 0, 63, 0, 0, 76, 76, 76, 0, 0, 76, 76, 100, 76, 76, 76, 112, 76, 112, 100, 100, 112, 100,
  100, 112, 127, 100, 127, 127, 127, 100, 133, 135, 0, 3209, 56, 56, 56, 56, 142, 56, 56, 56, 56, 212, 215, 70, 70, 121,
  121, 221, 121, 121, 121, 121, 121, 121, 595, 121, 121, 121, 121, 121, 56, 599, 56, 56, 70, 186, 70, 70, 70, 70, 70,
  70, 70, 70, 56, 56, 201, 56, 56, 56, 313, 56, 70, 70, 70, 70, 5377, 121, 121, 121, 121, 121, 121, 241, 0, 261, 70, 70,
  70, 56, 621, 56, 56, 466, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 309, 56, 481, 56, 56, 56, 56,
  70, 70, 70, 121, 121, 121, 121, 121, 121, 121, 121, 552, 56, 248, 56, 56, 56, 56, 56, 510, 56, 0, 70, 70, 268, 70, 70,
  70, 519, 56, 86, 86, 56, 70, 70, 70, 70, 70, 70, 70, 387, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 585, 56, 56, 70,
  70, 70, 70, 527, 70, 70, 70, 70, 56, 56, 533, 56, 56, 56, 56, 56, 56, 56, 485, 70, 70, 121, 489, 121, 121, 121, 121,
  121, 539, 56, 56, 56, 70, 543, 70, 121, 121, 547, 121, 121, 121, 121, 121, 121, 121, 121, 121, 598, 121, 121, 56, 56,
  56, 56, 121, 121, 554, 121, 121, 121, 121, 56, 56, 56, 56, 56, 56, 56, 0, 70, 70, 70, 70, 164, 70, 70, 70, 70, 70, 70,
  614, 121, 121, 121, 121, 121, 56, 0, 70, 70, 70, 70, 56, 56, 56, 56, 250, 56, 56, 56, 56, 56, 256, 5377, 70, 70, 70,
  70, 70, 70, 360, 70, 70, 363, 70, 364, 365, 70, 367, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 77, 82, 0, 0, 64, 86, 0, 0, 0,
  64, 0, 0, 77, 77, 77, 0, 0, 77, 77, 101, 77, 77, 77, 113, 77, 113, 101, 101, 113, 101, 101, 113, 128, 101, 128, 128,
  128, 101, 133, 135, 0, 3209, 56, 56, 56, 56, 143, 56, 56, 56, 56, 314, 70, 70, 70, 70, 5377, 121, 121, 121, 121, 121,
  121, 121, 121, 121, 121, 422, 121, 121, 121, 121, 121, 70, 187, 70, 70, 70, 70, 70, 70, 70, 70, 56, 56, 202, 56, 56,
  56, 345, 56, 56, 348, 56, 349, 350, 56, 352, 56, 56, 354, 355, 56, 252, 56, 56, 346, 56, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 0, 0, 70, 70, 70, 70, 70, 382, 70, 70, 70, 70, 70, 70, 70, 70, 56, 56, 56, 394, 56, 56, 0, 70, 70, 70, 70,
  446, 70, 70, 449, 70, 70, 70, 70, 70, 530, 56, 56, 56, 56, 56, 56, 56, 537, 56, 56, 397, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 413, 121, 121, 416, 121, 121, 121, 121, 121,
  121, 121, 121, 121, 121, 121, 0, 0, 56, 56, 56, 0, 0, 0, 0, 56, 56, 56, 56, 56, 436, 56, 56, 56, 56, 56, 56, 509, 56,
  56, 511, 70, 70, 70, 70, 70, 70, 0, 0, 0, 65, 0, 0, 0, 0, 69, 0, 0, 78, 82, 0, 0, 65, 86, 0, 0, 0, 65, 0, 0, 78, 78,
  78, 0, 0, 78, 78, 102, 78, 78, 78, 114, 78, 114, 119, 102, 114, 119, 119, 114, 129, 119, 129, 129, 129, 119, 133, 135,
  0, 3209, 56, 56, 56, 56, 56, 56, 146, 56, 56, 0, 70, 70, 70, 261, 70, 70, 70, 70, 70, 70, 70, 70, 70, 298, 56, 56, 56,
  56, 56, 56, 56, 306, 56, 56, 56, 70, 82, 175, 56, 56, 86, 86, 86, 0, 0, 180, 0, 3209, 70, 70, 184, 441, 241, 0, 70,
  70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 268, 452, 261, 0, 56, 455, 456, 56, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70,
  272, 274, 70, 70, 0, 0, 56, 70, 467, 468, 70, 469, 70, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 0, 5377, 70, 70, 70,
  261, 150, 56, 56, 154, 0, 70, 70, 70, 70, 70, 70, 70, 70, 169, 70, 70, 383, 70, 70, 70, 70, 388, 70, 70, 56, 56, 56,
  56, 395, 56, 173, 82, 0, 56, 56, 86, 86, 179, 0, 0, 56, 0, 3209, 70, 70, 70, 261, 0, 56, 520, 86, 56, 70, 70, 70, 70,
  70, 70, 70, 56, 56, 473, 56, 56, 56, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 491, 121, 121, 121, 56, 209, 56, 56,
  213, 70, 192, 70, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 236, 236, 237, 237, 56, 231, 121, 121, 235,
  133, 0, 135, 0, 3209, 56, 56, 56, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 227, 121, 121, 0, 0, 0, 66, 0,
  0, 0, 0, 0, 0, 0, 79, 82, 0, 0, 66, 86, 0, 0, 0, 66, 0, 0, 79, 79, 79, 0, 0, 79, 79, 103, 79, 79, 79, 115, 79, 115,
  103, 103, 115, 103, 103, 115, 130, 103, 130, 130, 130, 103, 133, 135, 0, 3209, 56, 56, 56, 56, 56, 56, 56, 56, 56, 70,
  70, 70, 121, 121, 121, 121, 226, 121, 121, 121, 121, 121, 121, 121, 133, 0, 135, 0, 3209, 56, 56, 56, 56, 56, 243, 56,
  56, 442, 70, 70, 70, 70, 70, 70, 70, 70, 70, 450, 70, 70, 70, 265, 70, 70, 70, 70, 70, 70, 273, 70, 70, 0, 0, 56, 70,
  263, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0, 0, 56, 56, 482, 483, 56, 484, 70, 70, 70, 121, 121, 121, 121, 121,
  121, 121, 56, 56, 56, 241, 56, 56, 56, 0, 70, 56, 86, 86, 56, 7349, 70, 70, 70, 70, 70, 288, 70, 70, 70, 70, 70, 192,
  70, 70, 196, 70, 56, 56, 56, 56, 56, 56, 70, 70, 70, 70, 5377, 121, 121, 121, 321, 121, 121, 70, 517, 70, 70, 0, 56,
  86, 86, 56, 70, 70, 70, 70, 70, 70, 70, 268, 70, 70, 70, 70, 70, 70, 70, 0, 0, 56, 121, 553, 121, 121, 121, 121, 121,
  56, 558, 56, 56, 56, 56, 56, 0, 70, 70, 70, 161, 70, 70, 70, 70, 70, 70, 70, 471, 56, 56, 56, 56, 56, 56, 56, 56, 56,
  252, 254, 56, 56, 0, 5377, 70, 70, 70, 70, 564, 70, 70, 70, 70, 70, 0, 86, 56, 70, 70, 70, 70, 70, 70, 70, 299, 300,
  56, 56, 56, 304, 56, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 223, 121, 121, 121, 121, 121, 590, 121, 121, 121, 121,
  121, 121, 121, 121, 121, 121, 56, 56, 56, 56, 56, 56, 561, 0, 70, 254, 279, 86, 56, 7349, 70, 274, 70, 70, 70, 70, 70,
  70, 70, 70, 70, 470, 56, 56, 56, 56, 56, 476, 56, 478, 56, 56, 294, 295, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 56, 70, 70, 70, 121, 121, 121, 121, 56, 311, 312, 56, 56, 70, 70, 70, 295, 5377, 121, 121, 121, 121, 121, 121,
  121, 501, 121, 121, 121, 236, 236, 237, 237, 56, 5377, 356, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0,
  0, 277, 268, 70, 70, 0, 56, 371, 86, 86, 56, 0, 70, 376, 70, 378, 70, 70, 518, 70, 0, 56, 86, 86, 56, 70, 70, 70, 70,
  70, 70, 70, 568, 86, 56, 70, 70, 572, 70, 70, 70, 70, 0, 0, 0, 0, 56, 56, 56, 56, 435, 56, 56, 438, 56, 56, 56, 56,
  508, 56, 56, 56, 56, 0, 70, 70, 70, 70, 70, 516, 70, 453, 56, 86, 86, 56, 0, 70, 70, 70, 70, 70, 463, 70, 70, 70, 261,
  70, 70, 0, 86, 569, 570, 70, 70, 70, 70, 70, 70, 56, 56, 56, 474, 56, 56, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121,
  121, 492, 121, 121, 121, 496, 121, 121, 121, 121, 121, 121, 121, 121, 121, 236, 236, 237, 237, 56, 56, 506, 56, 56,
  56, 56, 56, 56, 0, 70, 70, 70, 514, 70, 70, 369, 370, 56, 56, 86, 373, 56, 0, 70, 70, 70, 70, 70, 70, 56, 56, 56, 56,
  475, 56, 56, 56, 56, 56, 121, 121, 121, 121, 121, 594, 121, 121, 121, 121, 121, 121, 56, 56, 56, 56, 542, 70, 70, 121,
  546, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 236, 236, 237, 237, 504, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0,
  80, 82, 0, 0, 85, 87, 0, 0, 0, 85, 0, 0, 95, 95, 95, 0, 0, 95, 95, 104, 95, 95, 95, 116, 95, 116, 120, 120, 116, 120,
  120, 116, 131, 120, 131, 131, 131, 120, 133, 135, 0, 3209, 56, 56, 56, 56, 56, 56, 56, 56, 56, 70, 70, 70, 121, 121,
  121, 224, 121, 121, 121, 121, 56, 86, 86, 56, 7349, 70, 70, 70, 70, 70, 70, 70, 70, 291, 70, 70, 528, 70, 70, 70, 56,
  56, 56, 56, 56, 56, 56, 56, 56, 56, 351, 56, 56, 56, 56, 0, 121, 121, 121, 328, 121, 121, 121, 121, 121, 121, 121, 0,
  0, 56, 56, 56, 0, 70, 70, 445, 70, 70, 70, 448, 70, 70, 70, 70, 70, 70, 266, 70, 70, 70, 70, 70, 70, 70, 70, 0, 0, 56,
  480, 56, 56, 56, 56, 56, 70, 70, 487, 121, 121, 121, 121, 121, 121, 121, 56, 56, 559, 56, 56, 560, 56, 562, 70, 121,
  121, 121, 121, 498, 121, 121, 121, 121, 121, 121, 236, 236, 237, 237, 56, 56, 541, 56, 70, 70, 70, 121, 121, 121, 121,
  121, 121, 121, 121, 121, 121, 121, 121, 56, 56, 56, 508, 56, 624, 70, 121, 627, 121, 121, 121, 0, 70, 70, 56, 56, 56,
  56, 70, 70, 544, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 56, 56, 241, 56, 0, 0, 0, 68, 0, 0, 0, 0,
  0, 0, 0, 81, 82, 0, 0, 68, 88, 0, 0, 0, 68, 0, 0, 81, 81, 81, 0, 0, 81, 81, 105, 81, 81, 81, 117, 81, 117, 105, 105,
  117, 105, 105, 117, 132, 105, 132, 132, 132, 105, 133, 135, 0, 3209, 56, 56, 138, 56, 56, 56, 56, 56, 56, 70, 70, 70,
  121, 121, 121, 225, 121, 121, 121, 121, 70, 82, 0, 56, 177, 86, 178, 86, 0, 0, 56, 0, 3209, 70, 183, 70, 0, 56, 86,
  86, 56, 0, 70, 70, 70, 70, 70, 70, 464, 70, 70, 296, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 56, 308, 56, 185, 70, 70,
  70, 70, 70, 70, 194, 70, 70, 198, 56, 56, 56, 56, 56, 70, 70, 317, 70, 5377, 121, 121, 121, 121, 121, 121, 121, 332,
  334, 121, 121, 0, 0, 341, 56, 56, 121, 121, 233, 121, 133, 0, 135, 0, 3209, 238, 239, 56, 56, 56, 56, 244, 56, 86, 86,
  56, 7349, 70, 70, 70, 286, 70, 70, 289, 70, 70, 70, 293, 310, 56, 56, 56, 56, 315, 70, 70, 70, 5377, 318, 319, 121,
  121, 121, 121, 121, 330, 121, 121, 121, 121, 121, 0, 0, 56, 56, 56, 324, 121, 121, 121, 121, 121, 331, 121, 121, 121,
  121, 0, 0, 56, 56, 56, 0, 443, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 56, 392, 393, 56, 56, 56, 121, 121,
  414, 121, 121, 121, 121, 419, 121, 121, 121, 121, 121, 121, 426, 121, 121, 70, 133, 135, 0, 3209, 56, 56, 56, 56, 56,
  145, 56, 56, 56, 507, 56, 56, 56, 56, 56, 0, 70, 70, 70, 70, 515, 70, 0, 0, 0, 0, 56, 433, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 56, 0, 5377, 70, 70, 260, 70, 70, 0, 454, 86, 86, 56, 0, 458, 70, 70, 70, 70, 70, 70, 70, 70, 0, 56, 86, 86,
  521, 70, 522, 70, 70, 70, 70, 70, 56, 56, 56, 56, 303, 56, 56, 56, 56, 56, 56, 70, 70, 70, 70, 5377, 121, 121, 121,
  121, 121, 323, 56, 540, 56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,
  121, 425, 121, 121, 121, 121, 121, 555, 121, 121, 121, 56, 56, 56, 56, 56, 56, 56, 0, 70, 70, 70, 162, 70, 70, 70, 70,
  70, 70, 70, 70, 576, 56, 56, 579, 580, 56, 56, 583, 56, 56, 56, 56, 70, 587, 70, 0, 56, 86, 86, 56, 0, 70, 70, 70, 70,
  462, 70, 70, 70, 70, 385, 70, 70, 70, 70, 70, 56, 56, 56, 56, 56, 56, 56, 56, 307, 56, 56, 121, 121, 591, 592, 121,
  121, 121, 596, 121, 121, 121, 121, 508, 56, 56, 56, 152, 56, 0, 70, 157, 70, 70, 70, 70, 70, 70, 70, 70, 171, 605, 56,
  56, 56, 56, 56, 56, 56, 56, 70, 70, 70, 612, 121, 121, 121, 121, 121, 499, 121, 121, 121, 121, 121, 236, 236, 237,
  237, 56, 0, 0, 0, 0, 56, 56, 434, 56, 56, 56, 437, 56, 56, 56, 56, 56, 70, 316, 70, 70, 5377, 121, 121, 320, 121, 121,
  121, 70, 0, 56, 86, 86, 457, 0, 70, 459, 70, 70, 70, 70, 70, 70, 70, 267, 70, 70, 70, 70, 70, 70, 70, 70, 0, 276, 56,
  495, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 236, 236, 237, 237, 56, 70, 70, 121, 121, 121, 121, 121, 0, 70,
  70, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 548, 121, 549, 121, 121, 121, 70, 70, 577, 56, 56, 56, 56, 56, 56, 56,
  56, 56, 56, 70, 70, 70, 410, 121, 121, 589, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 56, 56, 56, 56,
  241, 56, 56, 0, 70, 121, 121, 121, 121, 133, 0, 135, 0, 3209, 56, 56, 56, 241, 56, 56, 56, 248, 56, 56, 56, 56, 56,
  56, 56, 0, 5377, 70, 70, 70, 70, 70, 359, 70, 70, 70, 70, 261, 70, 70, 70, 70, 56, 86, 86, 56, 7349, 283, 70, 70, 70,
  70, 70, 70, 70, 70, 70, 70, 285, 56, 56, 56, 56, 56, 56, 56, 281, 56, 56, 56, 249, 0, 70, 70, 70, 70, 269, 0, 56, 70,
  70, 70, 70, 70, 604, 70, 0, 56, 86, 86, 56, 0, 70, 70, 70, 461, 70, 70, 70, 70, 70, 56, 56, 56, 302, 56, 56, 56, 56,
  56, 56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 493, 121, 121, 121, 121, 121, 121, 616, 56, 0, 70, 70, 70, 70, 56,
  56, 56, 56, 607, 56, 56, 56, 56, 70, 70, 70, 121, 121, 121, 121, 121, 121, 121, 551, 121, 121, 121, 70, 133, 135, 0,
  3209, 56, 56, 56, 56, 144, 56, 56, 56, 56, 278, 56, 56, 70, 70, 70, 284, 5377, 121, 121, 121, 121, 121, 121, 56, 617,
  70, 618, 70, 619, 620, 56, 56, 622, 70, 188, 70, 70, 70, 70, 70, 70, 70, 70, 56, 56, 203, 56, 56, 56, 344, 56, 56, 56,
  56, 241, 56, 56, 56, 56, 56, 56, 56, 0, 70, 70, 70, 163, 70, 70, 70, 70, 70, 70, 70, 567, 0, 86, 56, 70, 70, 70, 70,
  70, 575, 70, 56, 86, 86, 56, 7349, 70, 70, 70, 70, 70, 70, 70, 70, 70, 292, 70, 0, 56, 86, 86, 56, 0, 70, 70, 460, 70,
  70, 70, 70, 70, 70, 269, 70, 70, 70, 70, 268, 70, 0, 0, 56, 121, 121, 121, 121, 329, 121, 121, 121, 121, 335, 121, 0,
  0, 56, 56, 56, 399, 56, 56, 56, 56, 56, 405, 56, 70, 70, 70, 121, 121, 121, 121, 70, 56, 121, 0, 0, 0, 0, 0, 0, 0, 0,
  45056, 45056, 45056, 0, 0, 45056, 45056, 0, 45056, 0, 0, 0, 0, 56, 56, 56, 241, 56, 56, 56, 56, 56, 56, 56, 56, 251,
  56, 56, 56, 56, 0, 5377, 258, 259, 70, 70, 505, 56, 56, 56, 56, 56, 56, 56, 56, 0, 70, 513, 70, 70, 70, 70, 297, 70,
  56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 248, 56, 56, 0, 0, 0, 0, 41984, 0, 0, 41984, 0, 0, 41984, 41984, 0, 0,
  0, 0, 41984, 133, 135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 41984, 41984, 41984, 0,
  41984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21504, 21504, 0, 0, 0, 0, 0, 90, 90, 43008, 0, 90, 43008, 0, 0, 0, 43008, 43098,
  43008, 43008, 0, 43008, 43008, 43008, 0, 43008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 0, 0, 0, 0, 0, 0, 0, 43008, 133,
  135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 95232, 96256, 97280, 69632, 69632, 69632, 0,
  69632, 69632, 94208, 69632, 69632, 69632, 94208, 69632, 0, 0, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 69632, 69632, 69632, 69632, 6144, 69632, 69632, 69632, 69632, 69632, 69632, 0, 45056, 45056, 45056, 0, 45056,
  0, 0, 0, 0, 0, 0, 45056, 0, 0, 0, 0, 0, 12288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13312, 0, 0, 0, 0, 0, 45056, 133,
  135, 0, 3209, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 0, 46080, 133, 135, 0, 3209, 69632, 0,
  69632, 69632, 69632, 69632, 69632, 69632, 69632
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  316, 320, 677, 324, 332, 336, 340, 344, 348, 352, 356, 360, 364, 532, 535, 535, 535, 392, 393, 393, 454, 328, 374,
  378, 473, 393, 382, 386, 535, 451, 399, 415, 427, 649, 534, 535, 535, 535, 537, 393, 393, 393, 393, 454, 495, 434,
  485, 439, 393, 403, 444, 388, 535, 521, 422, 408, 414, 427, 529, 591, 535, 535, 535, 536, 419, 393, 393, 393, 394,
  327, 433, 484, 438, 393, 509, 443, 448, 535, 520, 464, 409, 478, 427, 427, 649, 535, 535, 535, 390, 393, 393, 393,
  493, 458, 484, 438, 393, 509, 443, 448, 535, 520, 464, 410, 479, 427, 529, 650, 535, 535, 391, 393, 393, 494, 470,
  486, 393, 509, 443, 502, 535, 522, 466, 477, 427, 428, 535, 390, 393, 395, 483, 490, 509, 499, 503, 521, 465, 477,
  427, 535, 391, 394, 483, 507, 404, 501, 521, 465, 477, 429, 461, 511, 594, 425, 515, 519, 596, 526, 614, 614, 541,
  635, 558, 562, 565, 569, 571, 578, 575, 584, 580, 614, 614, 614, 614, 613, 614, 614, 614, 588, 600, 636, 614, 604,
  620, 614, 626, 631, 614, 615, 627, 614, 614, 614, 614, 614, 611, 614, 614, 614, 614, 614, 370, 636, 614, 602, 606,
  614, 614, 616, 546, 550, 634, 614, 614, 641, 548, 614, 614, 614, 614, 610, 614, 614, 614, 614, 614, 369, 635, 614,
  615, 605, 609, 614, 615, 662, 608, 613, 614, 614, 641, 646, 614, 614, 614, 614, 611, 614, 614, 614, 368, 367, 614,
  615, 605, 609, 614, 615, 662, 608, 613, 614, 615, 642, 607, 614, 614, 614, 612, 614, 614, 369, 637, 614, 604, 609,
  614, 616, 663, 611, 614, 614, 641, 370, 614, 611, 614, 655, 614, 544, 654, 614, 661, 659, 614, 614, 662, 614, 612,
  614, 614, 622, 614, 610, 672, 614, 614, 553, 621, 610, 554, 551, 670, 552, 667, 676, 128, 524288, 4, 12, 132, 2052,
  32772, 65540, 4128, 1073741952, 589828, 16777224, 8, 16, 16, 16, 16, 66048, 66052, 2052, 553648136, 590340, 165892,
  17301596, 554172508, 554172508, 979332, 1012484, 554191196, 554465628, -1642068836, 554596700, -1641544484, 554596828,
  554629468, 1628338524, -2097144, 554629596, -2097140, -2097128, -1087896356, -2031604, -1048548, -1048420, -1572788,
  -2091972, -1075313444, -1567620, -1567556, -1567492, -98852, 128, 0, 0, 16, 32, 128, 0, 512, 0, 536870920, 131072, 68,
  16777240, 24, 536870936, 24, 1610612760, 2097160, 29360136, 234881032, 268435464, 1610612744, -2147483640, 8, 8, 0,
  24, 24, 24, 24, 1073741824, 16, 56, 2097208, 29360184, 234881080, 1610612760, 2097160, 4194312, 8388616, 33554440,
  8388664, 16777272, 33554488, 67108920, 134217784, 268435512, 134217784, 268435512, 1610612792, -2147483592, 56, 16,
  24, 24, 24, 48, 2097208, 4194360, 134217784, 56, 56, 56, 56, 8, 0, 536870920, 64, 16777240, 24, 536870936, 134217752,
  268435480, -2147483624, 24, 24, 8388616, 33554440, 67108872, 134217736, 268435464, 268435464, 1073741832, -2147483640,
  8, 29360152, 24, 24, 32, 1073741824, 16777224, 16, 536870920, 64, 24, 2097176, 134217752, 24, 2097208, 4194360,
  8388664, 33554488, 67108920, 536870920, 24, 536870936, 2097176, 234881048, 268435480, -2147483624, 134217784,
  268435512, 536870968, 1073741880, -2147483592, 56, 536870920, 536870936, 2097176, 33554456, 67108888, 134217752,
  268435480, 134217752, 268435480, 24, 24, 1073741824, 8, 16, 16, 536870920, 8388616, 33554440, 134217736, 268435464,
  1073741832, 8, 8, 8, 134217752, 268435480, 24, 1073741848, 2097160, 4194312, 134217736, 8, 0, 2097176, 24, 2097160,
  4194312, 8, 8, 4194328, 8388632, 24, 2097208, 56, 24, 8, 56, 56, 56, 128, 4, 4, 8, 8, 8, 8, 0, 16, 2, 256, 2048, 0, 0,
  4, 8, 48, 64, 128, 0, 0, 2, 4, 0, 2, 0, 160, 1024, 1024, 768, 16, 1024, 768, 2064, 2320, 768, 1536, 2576, 2576, 237,
  2832, 2832, 2832, 253, 255, 255, 255, 2832, 255, 255, 7167, 0, 2303, 255, 255, 255, 16, 0, 32, 128, 8, 8, 8, 4194328,
  24, 2097208, 4194360, 56, 0, 1024, 0, 0, 1, 4, 8, 32, 64, 128, 0, 0, 0, 2, 0, 0, 0, 0, 1, 2, 192, 0, 0, 0, 4, 0, 1, 6,
  8, 48, 192, 192, 0, 6, 48, 0, 0, 0, 16, 0, 0, 1, 2, 4, 8, 16, 16, 32, 64, 128, 128, 128, 128, 8, 32, 0, 0, 0, 32, 32,
  0, 0, 2, 4, 8, 32, 128, 2, 0, 0, 2, 0, 4, 0, 0, 2, 4, 4, 4, 4, 24
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "separator",
  "identifier",
  "CName",
  "nsName",
  "documentation",
  "literalSegment",
  "'&amp;'",
  "'&amp;='",
  "'('",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'='",
  "'>>'",
  "'?'",
  "'['",
  "']'",
  "'attribute'",
  "'datatypes'",
  "'default'",
  "'div'",
  "'element'",
  "'empty'",
  "'external'",
  "'grammar'",
  "'include'",
  "'inherit'",
  "'list'",
  "'mixed'",
  "'namespace'",
  "'notAllowed'",
  "'parent'",
  "'start'",
  "'string'",
  "'text'",
  "'token'",
  "'{'",
  "'|'",
  "'|='",
  "'}'",
  "'~'"
);

(:~
 : Pass a line to fn:trace, without a generating a result. Actually,
 : create an empty result, but make it somehow dependent on trace,
 : so the optimizer does not eliminate the trace call.
 :
 : @param $line the line to be traced.
 : @return the empty sequence.
 :)
declare function p:trace($line as xs:string) as xs:string?
{
  if (trace($line, "trace")) then () else ""[.]
};

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  p:trace(concat("match tokenset=", string($token-set))),
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 1024
    return
      if ($result != 0) then
      (
        p:trace(concat("  done result=", $p:TOKEN[$result mod 64], " begin=", string($begin), " end=", string($end))),
        $result mod 64 - 1,
        $begin,
        $end - $result idiv 64
      )
      else
      (
        p:trace(concat("  fail begin=", string($begin), " end=", string($current - 1), " state=", string($previous-state))),
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
    (
      p:trace
      (
        concat
        (
          " next state=", string($current-state),
          " offset=", string($current - 1),
          " char=", string($c0),
          " class=", string($c1),
          if ($next-state < 1024) then
            ""
          else
            concat
            (
              " result=",
              $p:TOKEN[$next-state idiv 1024 mod 64],
              if ($next-state < 65536) then
                ""
              else
                concat(" trailing-context-size=", string($next-state idiv 65536))
            )
        )
      ),
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
    )
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 1
    let $i0 := $t * 632 + $state - 1
    let $i1 := $i0 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 10;

(:~
 : The index of the parser state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo := 11;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 12;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e2 - $p:l1 + 1),
    0,
    $state[$p:e2],
    subsequence($state, $p:e2),
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
        element TOKEN {$content}
      else
        element {$name} {$content}
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 2) then                                 (: separator :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 64 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    subsequence($state, $p:e2 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from parser state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore parser state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo{$state[$p:error]/@*, $state[$p:memo]/value}
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $i for input position $state[$p:e0].
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after successfully trying an alternative.
 : @param $v the id of the successful alternative.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoize($backtrack as item()+,
                           $state as item()+,
                           $v as xs:integer,
                           $i as xs:integer) as item()+
{
  $v,
  subsequence($backtrack, $p:lk + 1, $p:memo - $p:lk - 1),
  element memo
  {
    $state[$p:memo]/value,
    element value {attribute key {$backtrack[$p:e0] * 4 + $i}, $v}
  },
  subsequence($backtrack, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $i
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state the parser state.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoized($state as item()+, $i as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 4 + $i])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse annotatedPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-leadAnnotatedPrimary($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-followAnnotations($input, $state)
  return p:reduce($state, "annotatedPrimary", $count)
};

(:~
 : Try parsing annotatedPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-leadAnnotatedPrimary($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-followAnnotations($input, $state)
  return p:reduce($state, "annotatedPrimary", $count)
};

(:~
 : Parse innerParticle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-innerParticle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotatedPrimary($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12                             (: '*' :)
          or $state[$p:l1] = 13                             (: '+' :)
          or $state[$p:l1] = 18) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 12) then                        (: '*' :)
          let $state := p:shift(12, $input, $state)         (: '*' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '+' :)
          let $state := p:shift(13, $input, $state)         (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(18, $input, $state)         (: '?' :)
          return $state
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-followAnnotations($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "innerParticle", $count)
};

(:~
 : Try parsing innerParticle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-innerParticle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotatedPrimary($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12                             (: '*' :)
          or $state[$p:l1] = 13                             (: '+' :)
          or $state[$p:l1] = 18) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 12) then                        (: '*' :)
          let $state := p:shift(12, $input, $state)         (: '*' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '+' :)
          let $state := p:shift(13, $input, $state)         (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(18, $input, $state)         (: '?' :)
          return $state
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:try-followAnnotations($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "innerParticle", $count)
};

(:~
 : Parse ref.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ref($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(3, $input, $state)                  (: identifier :)
  return p:reduce($state, "ref", $count)
};

(:~
 : Try parsing ref.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ref($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(3, $input, $state)                  (: identifier :)
  return p:reduce($state, "ref", $count)
};

(:~
 : Parse datatypeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-datatypeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-literal($input, $state)
  return p:reduce($state, "datatypeValue", $count)
};

(:~
 : Try parsing datatypeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-datatypeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-literal($input, $state)
  return p:reduce($state, "datatypeValue", $count)
};

(:~
 : Parse div.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-div($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(24, $input, $state)                 (: 'div' :)
  let $state := p:lookahead1W(9, $input, $state)            (: separator | '{' :)
  let $state := p:shift(40, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-grammar($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: separator | '}' :)
  let $state := p:shift(43, $input, $state)                 (: '}' :)
  return p:reduce($state, "div", $count)
};

(:~
 : Try parsing div.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-div($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(24, $input, $state)                 (: 'div' :)
  let $state := p:lookahead1W(9, $input, $state)            (: separator | '{' :)
  let $state := p:shift(40, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-grammar($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: separator | '}' :)
  let $state := p:shift(43, $input, $state)                 (: '}' :)
  return p:reduce($state, "div", $count)
};

(:~
 : Parse foreignElementNameNotKeyword.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-foreignElementNameNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: identifier | CName :)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:shift(3, $input, $state)              (: identifier :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-prefixedName($input, $state)
      return $state
  return p:reduce($state, "foreignElementNameNotKeyword", $count)
};

(:~
 : Try parsing foreignElementNameNotKeyword.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-foreignElementNameNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: identifier | CName :)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:shift(3, $input, $state)              (: identifier :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-prefixedName($input, $state)
      return $state
  return p:reduce($state, "foreignElementNameNotKeyword", $count)
};

(:~
 : Parse annotationElementNotKeyword.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotationElementNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-foreignElementNameNotKeyword($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-annotationAttributesContent($input, $state)
  return p:reduce($state, "annotationElementNotKeyword", $count)
};

(:~
 : Try parsing annotationElementNotKeyword.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotationElementNotKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-foreignElementNameNotKeyword($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-annotationAttributesContent($input, $state)
  return p:reduce($state, "annotationElementNotKeyword", $count)
};

(:~
 : Parse includeDiv.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-includeDiv($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(24, $input, $state)                 (: 'div' :)
  let $state := p:lookahead1W(9, $input, $state)            (: separator | '{' :)
  let $state := p:shift(40, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-includeBody($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: separator | '}' :)
  let $state := p:shift(43, $input, $state)                 (: '}' :)
  return p:reduce($state, "includeDiv", $count)
};

(:~
 : Try parsing includeDiv.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-includeDiv($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(24, $input, $state)                 (: 'div' :)
  let $state := p:lookahead1W(9, $input, $state)            (: separator | '{' :)
  let $state := p:shift(40, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-includeBody($input, $state)
  let $state := p:lookahead1W(10, $input, $state)           (: separator | '}' :)
  let $state := p:shift(43, $input, $state)                 (: '}' :)
  return p:reduce($state, "includeDiv", $count)
};

(:~
 : Parse includeComponent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-includeComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(15, $input, $state)            (: identifier | 'div' | 'start' :)
  let $state :=
    if ($state[$p:l1] = 36) then                            (: 'start' :)
      let $state := p:parse-start($input, $state)
      return $state
    else if ($state[$p:l1] = 3) then                        (: identifier :)
      let $state := p:parse-define($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-includeDiv($input, $state)
      return $state
  return p:reduce($state, "includeComponent", $count)
};

(:~
 : Try parsing includeComponent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-includeComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(15, $input, $state)            (: identifier | 'div' | 'start' :)
  let $state :=
    if ($state[$p:l1] = 36) then                            (: 'start' :)
      let $state := p:try-start($input, $state)
      return $state
    else if ($state[$p:l1] = 3) then                        (: identifier :)
      let $state := p:try-define($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-includeDiv($input, $state)
      return $state
  return p:reduce($state, "includeComponent", $count)
};

(:~
 : Parse annotatedIncludeComponent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotatedIncludeComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-includeComponent($input, $state)
  return p:reduce($state, "annotatedIncludeComponent", $count)
};

(:~
 : Try parsing annotatedIncludeComponent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotatedIncludeComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-includeComponent($input, $state)
  return p:reduce($state, "annotatedIncludeComponent", $count)
};

(:~
 : Parse includeMember.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-includeMember($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:lookahead2W(21, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 4                                   (: CName :)
     or $state[$p:lk] = 1219) then                          (: identifier '[' :)
      let $state := p:parse-annotationElementNotKeyword($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-annotatedIncludeComponent($input, $state)
      return $state
  return p:reduce($state, "includeMember", $count)
};

(:~
 : Try parsing includeMember.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-includeMember($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:lookahead2W(21, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 4                                   (: CName :)
     or $state[$p:lk] = 1219) then                          (: identifier '[' :)
      let $state := p:try-annotationElementNotKeyword($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-annotatedIncludeComponent($input, $state)
      return $state
  return p:reduce($state, "includeMember", $count)
};

(:~
 : Parse the 1st loop of production includeBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-includeBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(23, $input, $state)         (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:parse-includeMember($input, $state)
        return p:parse-includeBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production includeBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-includeBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(23, $input, $state)         (: separator | identifier | CName | documentation | '[' |
                                                               'div' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:try-includeMember($input, $state)
        return p:try-includeBody-1($input, $state)
};

(:~
 : Parse includeBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-includeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-includeBody-1($input, $state)
  return p:reduce($state, "includeBody", $count)
};

(:~
 : Try parsing includeBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-includeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-includeBody-1($input, $state)
  return p:reduce($state, "includeBody", $count)
};

(:~
 : Parse optIncludeBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-optIncludeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(25, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '[' | 'div' | 'include' | 'start' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:shift(40, $input, $state)             (: '{' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-includeBody($input, $state)
      let $state := p:lookahead1W(10, $input, $state)       (: separator | '}' :)
      let $state := p:shift(43, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "optIncludeBody", $count)
};

(:~
 : Try parsing optIncludeBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-optIncludeBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(25, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '[' | 'div' | 'include' | 'start' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:shift(40, $input, $state)             (: '{' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:try-includeBody($input, $state)
      let $state := p:lookahead1W(10, $input, $state)       (: separator | '}' :)
      let $state := p:shift(43, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "optIncludeBody", $count)
};

(:~
 : Parse optInherit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-optInherit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(35, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'inherit' | 'start' | '{' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:shift(30, $input, $state)             (: 'inherit' :)
      let $state := p:lookahead1W(7, $input, $state)        (: separator | '=' :)
      let $state := p:shift(16, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(38, $input, $state)       (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
      let $state := p:parse-identifierOrKeyword($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "optInherit", $count)
};

(:~
 : Try parsing optInherit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-optInherit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(35, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'inherit' | 'start' | '{' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:shift(30, $input, $state)             (: 'inherit' :)
      let $state := p:lookahead1W(7, $input, $state)        (: separator | '=' :)
      let $state := p:shift(16, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(38, $input, $state)       (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
      let $state := p:try-identifierOrKeyword($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "optInherit", $count)
};

(:~
 : Parse anyURILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-anyURILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-literal($input, $state)
  return p:reduce($state, "anyURILiteral", $count)
};

(:~
 : Try parsing anyURILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-anyURILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-literal($input, $state)
  return p:reduce($state, "anyURILiteral", $count)
};

(:~
 : Parse include.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-include($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(29, $input, $state)                 (: 'include' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-anyURILiteral($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-optInherit($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-optIncludeBody($input, $state)
  return p:reduce($state, "include", $count)
};

(:~
 : Try parsing include.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-include($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(29, $input, $state)                 (: 'include' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-anyURILiteral($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-optInherit($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-optIncludeBody($input, $state)
  return p:reduce($state, "include", $count)
};

(:~
 : Parse define.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-define($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(3, $input, $state)                  (: identifier :)
  let $state := p:lookahead1W(18, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state := p:parse-assignOp($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-pattern($input, $state)
  return p:reduce($state, "define", $count)
};

(:~
 : Try parsing define.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-define($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(3, $input, $state)                  (: identifier :)
  let $state := p:lookahead1W(18, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state := p:try-assignOp($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-pattern($input, $state)
  return p:reduce($state, "define", $count)
};

(:~
 : Parse assignOp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-assignOp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(17, $input, $state)            (: '&=' | '=' | '|=' :)
  let $state :=
    if ($state[$p:l1] = 16) then                            (: '=' :)
      let $state := p:shift(16, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: '|=' :)
      let $state := p:shift(42, $input, $state)             (: '|=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(9, $input, $state)              (: '&=' :)
      return $state
  return p:reduce($state, "assignOp", $count)
};

(:~
 : Try parsing assignOp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-assignOp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(17, $input, $state)            (: '&=' | '=' | '|=' :)
  let $state :=
    if ($state[$p:l1] = 16) then                            (: '=' :)
      let $state := p:shift(16, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: '|=' :)
      let $state := p:shift(42, $input, $state)             (: '|=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(9, $input, $state)              (: '&=' :)
      return $state
  return p:reduce($state, "assignOp", $count)
};

(:~
 : Parse start.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-start($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(36, $input, $state)                 (: 'start' :)
  let $state := p:lookahead1W(18, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state := p:parse-assignOp($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-pattern($input, $state)
  return p:reduce($state, "start", $count)
};

(:~
 : Try parsing start.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-start($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(36, $input, $state)                 (: 'start' :)
  let $state := p:lookahead1W(18, $input, $state)           (: separator | '&=' | '=' | '|=' :)
  let $state := p:try-assignOp($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-pattern($input, $state)
  return p:reduce($state, "start", $count)
};

(:~
 : Parse component.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-component($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(20, $input, $state)            (: identifier | 'div' | 'include' | 'start' :)
  let $state :=
    if ($state[$p:l1] = 36) then                            (: 'start' :)
      let $state := p:parse-start($input, $state)
      return $state
    else if ($state[$p:l1] = 3) then                        (: identifier :)
      let $state := p:parse-define($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state := p:parse-include($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-div($input, $state)
      return $state
  return p:reduce($state, "component", $count)
};

(:~
 : Try parsing component.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-component($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(20, $input, $state)            (: identifier | 'div' | 'include' | 'start' :)
  let $state :=
    if ($state[$p:l1] = 36) then                            (: 'start' :)
      let $state := p:try-start($input, $state)
      return $state
    else if ($state[$p:l1] = 3) then                        (: identifier :)
      let $state := p:try-define($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state := p:try-include($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-div($input, $state)
      return $state
  return p:reduce($state, "component", $count)
};

(:~
 : Parse annotatedComponent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotatedComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-component($input, $state)
  return p:reduce($state, "annotatedComponent", $count)
};

(:~
 : Try parsing annotatedComponent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotatedComponent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-component($input, $state)
  return p:reduce($state, "annotatedComponent", $count)
};

(:~
 : Parse member.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-member($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:lookahead2W(21, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 4                                   (: CName :)
     or $state[$p:lk] = 1219) then                          (: identifier '[' :)
      let $state := p:parse-annotationElementNotKeyword($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-annotatedComponent($input, $state)
      return $state
  return p:reduce($state, "member", $count)
};

(:~
 : Try parsing member.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-member($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:lookahead2W(21, $input, $state)       (: separator | '&=' | '=' | '[' | '|=' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 4                                   (: CName :)
     or $state[$p:lk] = 1219) then                          (: identifier '[' :)
      let $state := p:try-annotationElementNotKeyword($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-annotatedComponent($input, $state)
      return $state
  return p:reduce($state, "member", $count)
};

(:~
 : Parse the 1st loop of production grammar (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-grammar-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(24, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               '[' | 'div' | 'include' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 1                                 (: END :)
       or $state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:parse-member($input, $state)
        return p:parse-grammar-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production grammar (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-grammar-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(24, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               '[' | 'div' | 'include' | 'start' | '}' :)
    return
      if ($state[$p:l1] = 1                                 (: END :)
       or $state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:try-member($input, $state)
        return p:try-grammar-1($input, $state)
};

(:~
 : Parse grammar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-grammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-grammar-1($input, $state)
  return p:reduce($state, "grammar", $count)
};

(:~
 : Try parsing grammar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-grammar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-grammar-1($input, $state)
  return p:reduce($state, "grammar", $count)
};

(:~
 : Parse exceptNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-exceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: nsName | '*' :)
  let $state :=
    if ($state[$p:l1] = 5) then                             (: nsName :)
      let $state := p:shift(5, $input, $state)              (: nsName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(12, $input, $state)             (: '*' :)
      return $state
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '-' :)
  let $state := p:shift(15, $input, $state)                 (: '-' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-leadAnnotatedSimpleNameClass($input, $state)
  return p:reduce($state, "exceptNameClass", $count)
};

(:~
 : Try parsing exceptNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-exceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: nsName | '*' :)
  let $state :=
    if ($state[$p:l1] = 5) then                             (: nsName :)
      let $state := p:shift(5, $input, $state)              (: nsName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(12, $input, $state)             (: '*' :)
      return $state
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '-' :)
  let $state := p:shift(15, $input, $state)                 (: '-' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-leadAnnotatedSimpleNameClass($input, $state)
  return p:reduce($state, "exceptNameClass", $count)
};

(:~
 : Parse leadAnnotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-leadAnnotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-exceptNameClass($input, $state)
  return p:reduce($state, "leadAnnotatedExceptNameClass", $count)
};

(:~
 : Try parsing leadAnnotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-leadAnnotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-exceptNameClass($input, $state)
  return p:reduce($state, "leadAnnotatedExceptNameClass", $count)
};

(:~
 : Parse annotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-leadAnnotatedExceptNameClass($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-followAnnotations($input, $state)
  return p:reduce($state, "annotatedExceptNameClass", $count)
};

(:~
 : Try parsing annotatedExceptNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotatedExceptNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-leadAnnotatedExceptNameClass($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-followAnnotations($input, $state)
  return p:reduce($state, "annotatedExceptNameClass", $count)
};

(:~
 : Parse the 1st loop of production followAnnotations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-followAnnotations-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '{' | '|' | '}' :)
    return
      if ($state[$p:l1] != 17) then                         (: '>>' :)
        $state
      else
        let $state := p:shift(17, $input, $state)           (: '>>' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:parse-annotationElement($input, $state)
        return p:parse-followAnnotations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production followAnnotations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-followAnnotations-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '>>' | '?' | '[' | 'div' |
                                                               'include' | 'start' | '{' | '|' | '}' :)
    return
      if ($state[$p:l1] != 17) then                         (: '>>' :)
        $state
      else
        let $state := p:shift(17, $input, $state)           (: '>>' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:try-annotationElement($input, $state)
        return p:try-followAnnotations-1($input, $state)
};

(:~
 : Parse followAnnotations.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-followAnnotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-followAnnotations-1($input, $state)
  return p:reduce($state, "followAnnotations", $count)
};

(:~
 : Try parsing followAnnotations.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-followAnnotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-followAnnotations-1($input, $state)
  return p:reduce($state, "followAnnotations", $count)
};

(:~
 : Parse simpleNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-simpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:shift(4, $input, $state)              (: CName :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: nsName :)
      let $state := p:shift(5, $input, $state)              (: nsName :)
      return $state
    else if ($state[$p:l1] = 12) then                       (: '*' :)
      let $state := p:shift(12, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "simpleNameClass", $count)
};

(:~
 : Try parsing simpleNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-simpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:shift(4, $input, $state)              (: CName :)
      return $state
    else if ($state[$p:l1] = 5) then                        (: nsName :)
      let $state := p:shift(5, $input, $state)              (: nsName :)
      return $state
    else if ($state[$p:l1] = 12) then                       (: '*' :)
      let $state := p:shift(12, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "simpleNameClass", $count)
};

(:~
 : Parse leadAnnotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-leadAnnotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: separator | identifier | CName | nsName | '(' | '*' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:l1] = 10) then                            (: '(' :)
      let $state := p:shift(10, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-innerNameClass($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: separator | ')' :)
      let $state := p:shift(11, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-simpleNameClass($input, $state)
      return $state
  return p:reduce($state, "leadAnnotatedSimpleNameClass", $count)
};

(:~
 : Try parsing leadAnnotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-leadAnnotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: separator | identifier | CName | nsName | '(' | '*' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:l1] = 10) then                            (: '(' :)
      let $state := p:shift(10, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:try-innerNameClass($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: separator | ')' :)
      let $state := p:shift(11, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-simpleNameClass($input, $state)
      return $state
  return p:reduce($state, "leadAnnotatedSimpleNameClass", $count)
};

(:~
 : Parse annotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-leadAnnotatedSimpleNameClass($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-followAnnotations($input, $state)
  return p:reduce($state, "annotatedSimpleNameClass", $count)
};

(:~
 : Try parsing annotatedSimpleNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotatedSimpleNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-leadAnnotatedSimpleNameClass($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-followAnnotations($input, $state)
  return p:reduce($state, "annotatedSimpleNameClass", $count)
};

(:~
 : Parse the 1st loop of production innerNameClass (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-innerNameClass-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: separator | ')' | '{' | '|' :)
    return
      if ($state[$p:l1] != 41) then                         (: '|' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: '|' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:parse-annotatedSimpleNameClass($input, $state)
        return p:parse-innerNameClass-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production innerNameClass (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-innerNameClass-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(19, $input, $state)         (: separator | ')' | '{' | '|' :)
    return
      if ($state[$p:l1] != 41) then                         (: '|' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: '|' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:try-annotatedSimpleNameClass($input, $state)
        return p:try-innerNameClass-1($input, $state)
};

(:~
 : Parse innerNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-innerNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(47, $input, $state)           (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: documentation :)
      let $state := p:lookahead2W(47, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 5                              (: '*' :)
          or $state[$p:l1] = 12) then                       (: '*' :)
      let $state := p:lookahead2W(22, $input, $state)       (: separator | ')' | '-' | '>>' | '{' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 211                            (: '[' identifier :)
          or $state[$p:lk] = 275                            (: '[' CName :)
          or $state[$p:lk] = 326                            (: documentation nsName :)
          or $state[$p:lk] = 390                            (: documentation documentation :)
          or $state[$p:lk] = 774                            (: documentation '*' :)
          or $state[$p:lk] = 1222                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2515) then                     (: '[' 'token' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-annotatedSimpleNameClass($input, $state)
          let $state := p:try-innerNameClass-1($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 2)
            else
              p:memoize($backtrack, $state, -2, 2)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -2
     or $state[$p:lk] = 965                                 (: nsName '-' :)
     or $state[$p:lk] = 972) then                           (: '*' '-' :)
      let $state := p:parse-annotatedExceptNameClass($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-annotatedSimpleNameClass($input, $state)
      let $state := p:parse-innerNameClass-1($input, $state)
      return $state
  return p:reduce($state, "innerNameClass", $count)
};

(:~
 : Try parsing innerNameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-innerNameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(47, $input, $state)           (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: documentation :)
      let $state := p:lookahead2W(47, $input, $state)       (: separator | identifier | CName | nsName | documentation |
                                                               '(' | '*' | '[' | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 5                              (: '*' :)
          or $state[$p:l1] = 12) then                       (: '*' :)
      let $state := p:lookahead2W(22, $input, $state)       (: separator | ')' | '-' | '>>' | '{' | '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 211                            (: '[' identifier :)
          or $state[$p:lk] = 275                            (: '[' CName :)
          or $state[$p:lk] = 326                            (: documentation nsName :)
          or $state[$p:lk] = 390                            (: documentation documentation :)
          or $state[$p:lk] = 774                            (: documentation '*' :)
          or $state[$p:lk] = 1222                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2515) then                     (: '[' 'token' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-annotatedSimpleNameClass($input, $state)
          let $state := p:try-innerNameClass-1($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 2)
            else
              p:memoize($backtrack, $state, -2, 2)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -2
     or $state[$p:lk] = 965                                 (: nsName '-' :)
     or $state[$p:lk] = 972) then                           (: '*' '-' :)
      let $state := p:try-annotatedExceptNameClass($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-annotatedSimpleNameClass($input, $state)
      let $state := p:try-innerNameClass-1($input, $state)
      return $state
  return p:reduce($state, "innerNameClass", $count)
};

(:~
 : Parse nameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-innerNameClass($input, $state)
  return p:reduce($state, "nameClass", $count)
};

(:~
 : Try parsing nameClass.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-nameClass($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-innerNameClass($input, $state)
  return p:reduce($state, "nameClass", $count)
};

(:~
 : Parse primary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-primary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 4                                   (: CName :)
     or $state[$p:l1] = 37                                  (: 'string' :)
     or $state[$p:l1] = 39) then                            (: 'token' :)
      let $state := p:parse-datatypeName($input, $state)
      let $state := p:lookahead1W(33, $input, $state)       (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '&' | ')' | '*' | '+' | ',' | '>>' |
                                                               '?' | '[' | 'div' | 'include' | 'start' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 7) then                         (: literalSegment :)
          let $state := p:parse-datatypeValue($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-optParams($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 7) then                        (: literalSegment :)
      let $state := p:parse-datatypeValue($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:shift(26, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:shift(34, $input, $state)             (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:shift(38, $input, $state)             (: 'text' :)
      return $state
    else if ($state[$p:l1] = 3                              (: identifier :)
          or $state[$p:l1] = 35) then                       (: 'parent' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: 'parent' :)
          let $state := p:shift(35, $input, $state)         (: 'parent' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(3, $input, $state)        (: separator | identifier :)
      let $state := p:parse-ref($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:shift(27, $input, $state)             (: 'external' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-anyURILiteral($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-optInherit($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:l1] = 28) then                        (: 'grammar' :)
          let $state := p:shift(28, $input, $state)         (: 'grammar' :)
          let $state := p:lookahead1W(9, $input, $state)    (: separator | '{' :)
          let $state := p:shift(40, $input, $state)         (: '{' :)
          let $state := p:lookahead1W(2, $input, $state)    (: EPSILON | separator :)
          let $state := p:parse-grammar($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:l1] = 32) then                    (: 'mixed' :)
              let $state := p:shift(32, $input, $state)     (: 'mixed' :)
              return $state
            else if ($state[$p:l1] = 31) then               (: 'list' :)
              let $state := p:shift(31, $input, $state)     (: 'list' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state :=
                if ($state[$p:l1] = 25) then                (: 'element' :)
                  let $state := p:shift(25, $input, $state) (: 'element' :)
                  return $state
                else if ($state[$p:error]) then
                  $state
                else
                  let $state := p:shift(21, $input, $state) (: 'attribute' :)
                  return $state
              let $state := p:lookahead1W(2, $input, $state) (: EPSILON | separator :)
              let $state := p:parse-nameClass($input, $state)
              return $state
          let $state := p:lookahead1W(9, $input, $state)    (: separator | '{' :)
          let $state := p:shift(40, $input, $state)         (: '{' :)
          let $state := p:lookahead1W(2, $input, $state)    (: EPSILON | separator :)
          let $state := p:parse-pattern($input, $state)
          return $state
      let $state := p:lookahead1W(10, $input, $state)       (: separator | '}' :)
      let $state := p:shift(43, $input, $state)             (: '}' :)
      return $state
  return p:reduce($state, "primary", $count)
};

(:~
 : Try parsing primary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-primary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 4                                   (: CName :)
     or $state[$p:l1] = 37                                  (: 'string' :)
     or $state[$p:l1] = 39) then                            (: 'token' :)
      let $state := p:try-datatypeName($input, $state)
      let $state := p:lookahead1W(33, $input, $state)       (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '&' | ')' | '*' | '+' | ',' | '>>' |
                                                               '?' | '[' | 'div' | 'include' | 'start' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 7) then                         (: literalSegment :)
          let $state := p:try-datatypeValue($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-optParams($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 7) then                        (: literalSegment :)
      let $state := p:try-datatypeValue($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:shift(26, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:shift(34, $input, $state)             (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:shift(38, $input, $state)             (: 'text' :)
      return $state
    else if ($state[$p:l1] = 3                              (: identifier :)
          or $state[$p:l1] = 35) then                       (: 'parent' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35) then                   (: 'parent' :)
          let $state := p:shift(35, $input, $state)         (: 'parent' :)
          return $state
        else
          $state
      let $state := p:lookahead1W(3, $input, $state)        (: separator | identifier :)
      let $state := p:try-ref($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:shift(27, $input, $state)             (: 'external' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:try-anyURILiteral($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:try-optInherit($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:l1] = 28) then                        (: 'grammar' :)
          let $state := p:shift(28, $input, $state)         (: 'grammar' :)
          let $state := p:lookahead1W(9, $input, $state)    (: separator | '{' :)
          let $state := p:shift(40, $input, $state)         (: '{' :)
          let $state := p:lookahead1W(2, $input, $state)    (: EPSILON | separator :)
          let $state := p:try-grammar($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:l1] = 32) then                    (: 'mixed' :)
              let $state := p:shift(32, $input, $state)     (: 'mixed' :)
              return $state
            else if ($state[$p:l1] = 31) then               (: 'list' :)
              let $state := p:shift(31, $input, $state)     (: 'list' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state :=
                if ($state[$p:l1] = 25) then                (: 'element' :)
                  let $state := p:shift(25, $input, $state) (: 'element' :)
                  return $state
                else if ($state[$p:error]) then
                  $state
                else
                  let $state := p:shift(21, $input, $state) (: 'attribute' :)
                  return $state
              let $state := p:lookahead1W(2, $input, $state) (: EPSILON | separator :)
              let $state := p:try-nameClass($input, $state)
              return $state
          let $state := p:lookahead1W(9, $input, $state)    (: separator | '{' :)
          let $state := p:shift(40, $input, $state)         (: '{' :)
          let $state := p:lookahead1W(2, $input, $state)    (: EPSILON | separator :)
          let $state := p:try-pattern($input, $state)
          return $state
      let $state := p:lookahead1W(10, $input, $state)       (: separator | '}' :)
      let $state := p:shift(43, $input, $state)             (: '}' :)
      return $state
  return p:reduce($state, "primary", $count)
};

(:~
 : Parse leadAnnotatedPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-leadAnnotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: separator | identifier | CName | literalSegment | '(' |
                                                               'attribute' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'list' | 'mixed' | 'notAllowed' | 'parent' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 10) then                            (: '(' :)
      let $state := p:shift(10, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-innerPattern($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: separator | ')' :)
      let $state := p:shift(11, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-primary($input, $state)
      return $state
  return p:reduce($state, "leadAnnotatedPrimary", $count)
};

(:~
 : Try parsing leadAnnotatedPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-leadAnnotatedPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: separator | identifier | CName | literalSegment | '(' |
                                                               'attribute' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'list' | 'mixed' | 'notAllowed' | 'parent' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 10) then                            (: '(' :)
      let $state := p:shift(10, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:try-innerPattern($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: separator | ')' :)
      let $state := p:shift(11, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-primary($input, $state)
      return $state
  return p:reduce($state, "leadAnnotatedPrimary", $count)
};

(:~
 : Parse param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(38, $input, $state)           (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state := p:parse-identifierOrKeyword($input, $state)
  let $state := p:lookahead1W(7, $input, $state)            (: separator | '=' :)
  let $state := p:shift(16, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-literal($input, $state)
  return p:reduce($state, "param", $count)
};

(:~
 : Try parsing param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(38, $input, $state)           (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state := p:try-identifierOrKeyword($input, $state)
  let $state := p:lookahead1W(7, $input, $state)            (: separator | '=' :)
  let $state := p:shift(16, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-literal($input, $state)
  return p:reduce($state, "param", $count)
};

(:~
 : Parse the 1st loop of production optParams (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-optParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(44, $input, $state)         (: separator | identifier | documentation | '[' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:parse-param($input, $state)
        return p:parse-optParams-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production optParams (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-optParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(44, $input, $state)         (: separator | identifier | documentation | '[' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' | '}' :)
    return
      if ($state[$p:l1] = 43) then                          (: '}' :)
        $state
      else
        let $state := p:try-param($input, $state)
        return p:try-optParams-1($input, $state)
};

(:~
 : Parse optParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-optParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(34, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '-' | '>>' | '?' | '[' |
                                                               'div' | 'include' | 'start' | '{' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:shift(40, $input, $state)             (: '{' :)
      let $state := p:parse-optParams-1($input, $state)
      let $state := p:shift(43, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "optParams", $count)
};

(:~
 : Try parsing optParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-optParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(34, $input, $state)           (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | '*' | '+' | ',' | '-' | '>>' | '?' | '[' |
                                                               'div' | 'include' | 'start' | '{' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '{' :)
      let $state := p:shift(40, $input, $state)             (: '{' :)
      let $state := p:try-optParams-1($input, $state)
      let $state := p:shift(43, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "optParams", $count)
};

(:~
 : Parse datatypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-datatypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(16, $input, $state)            (: CName | 'string' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:shift(4, $input, $state)              (: CName :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:shift(37, $input, $state)             (: 'string' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(39, $input, $state)             (: 'token' :)
      return $state
  return p:reduce($state, "datatypeName", $count)
};

(:~
 : Try parsing datatypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-datatypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(16, $input, $state)            (: CName | 'string' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:shift(4, $input, $state)              (: CName :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:shift(37, $input, $state)             (: 'string' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(39, $input, $state)             (: 'token' :)
      return $state
  return p:reduce($state, "datatypeName", $count)
};

(:~
 : Parse dataExcept.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-dataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(16, $input, $state)            (: CName | 'string' | 'token' :)
  let $state := p:parse-datatypeName($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-optParams($input, $state)
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '-' :)
  let $state := p:shift(15, $input, $state)                 (: '-' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-leadAnnotatedPrimary($input, $state)
  return p:reduce($state, "dataExcept", $count)
};

(:~
 : Try parsing dataExcept.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-dataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(16, $input, $state)            (: CName | 'string' | 'token' :)
  let $state := p:try-datatypeName($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-optParams($input, $state)
  let $state := p:lookahead1W(6, $input, $state)            (: separator | '-' :)
  let $state := p:shift(15, $input, $state)                 (: '-' :)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-leadAnnotatedPrimary($input, $state)
  return p:reduce($state, "dataExcept", $count)
};

(:~
 : Parse anyElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-anyElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(39, $input, $state)            (: identifier | CName | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:parse-prefixedName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "anyElementName", $count)
};

(:~
 : Try parsing anyElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-anyElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(39, $input, $state)            (: identifier | CName | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:try-prefixedName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "anyElementName", $count)
};

(:~
 : Parse nestedAnnotationElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nestedAnnotationElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-anyElementName($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-annotationAttributesContent($input, $state)
  return p:reduce($state, "nestedAnnotationElement", $count)
};

(:~
 : Try parsing nestedAnnotationElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-nestedAnnotationElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-anyElementName($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-annotationAttributesContent($input, $state)
  return p:reduce($state, "nestedAnnotationElement", $count)
};

(:~
 : Parse anyAttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-anyAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:parse-prefixedName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "anyAttributeName", $count)
};

(:~
 : Try parsing anyAttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-anyAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:try-prefixedName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "anyAttributeName", $count)
};

(:~
 : Parse the 1st loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotationAttributesContent-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(43, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    let $state :=
      if ($state[$p:l1] = 3                                 (: CName :)
       or $state[$p:l1] = 4                                 (: 'attribute' :)
       or $state[$p:l1] = 21                                (: 'datatypes' :)
       or $state[$p:l1] = 22                                (: 'default' :)
       or $state[$p:l1] = 23                                (: 'div' :)
       or $state[$p:l1] = 24                                (: 'element' :)
       or $state[$p:l1] = 25                                (: 'empty' :)
       or $state[$p:l1] = 26                                (: 'external' :)
       or $state[$p:l1] = 27                                (: 'grammar' :)
       or $state[$p:l1] = 28                                (: 'include' :)
       or $state[$p:l1] = 29                                (: 'inherit' :)
       or $state[$p:l1] = 30                                (: 'list' :)
       or $state[$p:l1] = 31                                (: 'mixed' :)
       or $state[$p:l1] = 32                                (: 'namespace' :)
       or $state[$p:l1] = 33                                (: 'notAllowed' :)
       or $state[$p:l1] = 34                                (: 'parent' :)
       or $state[$p:l1] = 35                                (: 'start' :)
       or $state[$p:l1] = 36                                (: 'string' :)
       or $state[$p:l1] = 37                                (: 'text' :)
       or $state[$p:l1] = 38                                (: 'token' :)
       or $state[$p:l1] = 39) then                          (: 'token' :)
        let $state := p:lookahead2W(14, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1027                             (: identifier '=' :)
      and $state[$p:lk] != 1028                             (: CName '=' :)
      and $state[$p:lk] != 1045                             (: 'attribute' '=' :)
      and $state[$p:lk] != 1046                             (: 'datatypes' '=' :)
      and $state[$p:lk] != 1047                             (: 'default' '=' :)
      and $state[$p:lk] != 1048                             (: 'div' '=' :)
      and $state[$p:lk] != 1049                             (: 'element' '=' :)
      and $state[$p:lk] != 1050                             (: 'empty' '=' :)
      and $state[$p:lk] != 1051                             (: 'external' '=' :)
      and $state[$p:lk] != 1052                             (: 'grammar' '=' :)
      and $state[$p:lk] != 1053                             (: 'include' '=' :)
      and $state[$p:lk] != 1054                             (: 'inherit' '=' :)
      and $state[$p:lk] != 1055                             (: 'list' '=' :)
      and $state[$p:lk] != 1056                             (: 'mixed' '=' :)
      and $state[$p:lk] != 1057                             (: 'namespace' '=' :)
      and $state[$p:lk] != 1058                             (: 'notAllowed' '=' :)
      and $state[$p:lk] != 1059                             (: 'parent' '=' :)
      and $state[$p:lk] != 1060                             (: 'start' '=' :)
      and $state[$p:lk] != 1061                             (: 'string' '=' :)
      and $state[$p:lk] != 1062                             (: 'text' '=' :)
      and $state[$p:lk] != 1063) then                       (: 'token' '=' :)
        $state
      else
        let $state := p:parse-anyAttributeName($input, $state)
        let $state := p:lookahead1W(7, $input, $state)      (: separator | '=' :)
        let $state := p:shift(16, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:parse-literal($input, $state)
        return p:parse-annotationAttributesContent-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotationAttributesContent-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(43, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    let $state :=
      if ($state[$p:l1] = 3                                 (: CName :)
       or $state[$p:l1] = 4                                 (: 'attribute' :)
       or $state[$p:l1] = 21                                (: 'datatypes' :)
       or $state[$p:l1] = 22                                (: 'default' :)
       or $state[$p:l1] = 23                                (: 'div' :)
       or $state[$p:l1] = 24                                (: 'element' :)
       or $state[$p:l1] = 25                                (: 'empty' :)
       or $state[$p:l1] = 26                                (: 'external' :)
       or $state[$p:l1] = 27                                (: 'grammar' :)
       or $state[$p:l1] = 28                                (: 'include' :)
       or $state[$p:l1] = 29                                (: 'inherit' :)
       or $state[$p:l1] = 30                                (: 'list' :)
       or $state[$p:l1] = 31                                (: 'mixed' :)
       or $state[$p:l1] = 32                                (: 'namespace' :)
       or $state[$p:l1] = 33                                (: 'notAllowed' :)
       or $state[$p:l1] = 34                                (: 'parent' :)
       or $state[$p:l1] = 35                                (: 'start' :)
       or $state[$p:l1] = 36                                (: 'string' :)
       or $state[$p:l1] = 37                                (: 'text' :)
       or $state[$p:l1] = 38                                (: 'token' :)
       or $state[$p:l1] = 39) then                          (: 'token' :)
        let $state := p:lookahead2W(14, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1027                             (: identifier '=' :)
      and $state[$p:lk] != 1028                             (: CName '=' :)
      and $state[$p:lk] != 1045                             (: 'attribute' '=' :)
      and $state[$p:lk] != 1046                             (: 'datatypes' '=' :)
      and $state[$p:lk] != 1047                             (: 'default' '=' :)
      and $state[$p:lk] != 1048                             (: 'div' '=' :)
      and $state[$p:lk] != 1049                             (: 'element' '=' :)
      and $state[$p:lk] != 1050                             (: 'empty' '=' :)
      and $state[$p:lk] != 1051                             (: 'external' '=' :)
      and $state[$p:lk] != 1052                             (: 'grammar' '=' :)
      and $state[$p:lk] != 1053                             (: 'include' '=' :)
      and $state[$p:lk] != 1054                             (: 'inherit' '=' :)
      and $state[$p:lk] != 1055                             (: 'list' '=' :)
      and $state[$p:lk] != 1056                             (: 'mixed' '=' :)
      and $state[$p:lk] != 1057                             (: 'namespace' '=' :)
      and $state[$p:lk] != 1058                             (: 'notAllowed' '=' :)
      and $state[$p:lk] != 1059                             (: 'parent' '=' :)
      and $state[$p:lk] != 1060                             (: 'start' '=' :)
      and $state[$p:lk] != 1061                             (: 'string' '=' :)
      and $state[$p:lk] != 1062                             (: 'text' '=' :)
      and $state[$p:lk] != 1063) then                       (: 'token' '=' :)
        $state
      else
        let $state := p:try-anyAttributeName($input, $state)
        let $state := p:lookahead1W(7, $input, $state)      (: separator | '=' :)
        let $state := p:shift(16, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:try-literal($input, $state)
        return p:try-annotationAttributesContent-1($input, $state)
};

(:~
 : Parse the 2nd loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotationAttributesContent-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(43, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 7) then                       (: literalSegment :)
            let $state := p:parse-literal($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-nestedAnnotationElement($input, $state)
            return $state
        return p:parse-annotationAttributesContent-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production annotationAttributesContent (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotationAttributesContent-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(43, $input, $state)         (: separator | identifier | CName | literalSegment | ']' |
                                                               'attribute' | 'datatypes' | 'default' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 7) then                       (: literalSegment :)
            let $state := p:try-literal($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-nestedAnnotationElement($input, $state)
            return $state
        return p:try-annotationAttributesContent-2($input, $state)
};

(:~
 : Parse annotationAttributesContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotationAttributesContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(1, $input, $state)             (: '[' :)
  let $state := p:shift(19, $input, $state)                 (: '[' :)
  let $state := p:parse-annotationAttributesContent-1($input, $state)
  let $state := p:parse-annotationAttributesContent-2($input, $state)
  let $state := p:shift(20, $input, $state)                 (: ']' :)
  return p:reduce($state, "annotationAttributesContent", $count)
};

(:~
 : Try parsing annotationAttributesContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotationAttributesContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(1, $input, $state)             (: '[' :)
  let $state := p:shift(19, $input, $state)                 (: '[' :)
  let $state := p:try-annotationAttributesContent-1($input, $state)
  let $state := p:try-annotationAttributesContent-2($input, $state)
  let $state := p:shift(20, $input, $state)                 (: ']' :)
  return p:reduce($state, "annotationAttributesContent", $count)
};

(:~
 : Parse foreignElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-foreignElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(39, $input, $state)            (: identifier | CName | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:parse-prefixedName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "foreignElementName", $count)
};

(:~
 : Try parsing foreignElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-foreignElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(39, $input, $state)            (: identifier | CName | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 4) then                             (: CName :)
      let $state := p:try-prefixedName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-identifierOrKeyword($input, $state)
      return $state
  return p:reduce($state, "foreignElementName", $count)
};

(:~
 : Parse annotationElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotationElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(39, $input, $state)            (: identifier | CName | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state := p:parse-foreignElementName($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-annotationAttributesContent($input, $state)
  return p:reduce($state, "annotationElement", $count)
};

(:~
 : Try parsing annotationElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotationElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(39, $input, $state)            (: identifier | CName | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
  let $state := p:try-foreignElementName($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-annotationAttributesContent($input, $state)
  return p:reduce($state, "annotationElement", $count)
};

(:~
 : Parse prefixedName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-prefixedName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(4, $input, $state)                  (: CName :)
  return p:reduce($state, "prefixedName", $count)
};

(:~
 : Try parsing prefixedName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-prefixedName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(4, $input, $state)                  (: CName :)
  return p:reduce($state, "prefixedName", $count)
};

(:~
 : Parse foreignAttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-foreignAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-prefixedName($input, $state)
  return p:reduce($state, "foreignAttributeName", $count)
};

(:~
 : Try parsing foreignAttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-foreignAttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-prefixedName($input, $state)
  return p:reduce($state, "foreignAttributeName", $count)
};

(:~
 : Parse the 1st loop of production documentations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-documentations-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(49, $input, $state)         (: separator | identifier | CName | nsName | documentation |
                                                               literalSegment | '(' | '*' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] != 6) then                          (: documentation :)
        $state
      else
        let $state := p:shift(6, $input, $state)            (: documentation :)
        return p:parse-documentations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production documentations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-documentations-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(49, $input, $state)         (: separator | identifier | CName | nsName | documentation |
                                                               literalSegment | '(' | '*' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] != 6) then                          (: documentation :)
        $state
      else
        let $state := p:shift(6, $input, $state)            (: documentation :)
        return p:try-documentations-1($input, $state)
};

(:~
 : Parse documentations.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-documentations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-documentations-1($input, $state)
  return p:reduce($state, "documentations", $count)
};

(:~
 : Try parsing documentations.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-documentations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-documentations-1($input, $state)
  return p:reduce($state, "documentations", $count)
};

(:~
 : Parse the 1st loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotations-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    let $state :=
      if ($state[$p:l1] = 4) then                           (: CName :)
        let $state := p:lookahead2W(14, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1028) then                       (: CName '=' :)
        $state
      else
        let $state := p:parse-foreignAttributeName($input, $state)
        let $state := p:lookahead1W(7, $input, $state)      (: separator | '=' :)
        let $state := p:shift(16, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:parse-literal($input, $state)
        return p:parse-annotations-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotations-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    let $state :=
      if ($state[$p:l1] = 4) then                           (: CName :)
        let $state := p:lookahead2W(14, $input, $state)     (: separator | '=' | '[' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1028) then                       (: CName '=' :)
        $state
      else
        let $state := p:try-foreignAttributeName($input, $state)
        let $state := p:lookahead1W(7, $input, $state)      (: separator | '=' :)
        let $state := p:shift(16, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:try-literal($input, $state)
        return p:try-annotations-1($input, $state)
};

(:~
 : Parse the 2nd loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotations-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state := p:parse-annotationElement($input, $state)
        return p:parse-annotations-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production annotations (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotations-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
    return
      if ($state[$p:l1] = 20) then                          (: ']' :)
        $state
      else
        let $state := p:try-annotationElement($input, $state)
        return p:try-annotations-2($input, $state)
};

(:~
 : Parse annotations.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-documentations($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: separator | identifier | CName | nsName |
                                                               literalSegment | '(' | '*' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:shift(19, $input, $state)             (: '[' :)
      let $state := p:parse-annotations-1($input, $state)
      let $state := p:parse-annotations-2($input, $state)
      let $state := p:shift(20, $input, $state)             (: ']' :)
      return $state
    else
      $state
  return p:reduce($state, "annotations", $count)
};

(:~
 : Try parsing annotations.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotations($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-documentations($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: separator | identifier | CName | nsName |
                                                               literalSegment | '(' | '*' | '[' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:shift(19, $input, $state)             (: '[' :)
      let $state := p:try-annotations-1($input, $state)
      let $state := p:try-annotations-2($input, $state)
      let $state := p:shift(20, $input, $state)             (: ']' :)
      return $state
    else
      $state
  return p:reduce($state, "annotations", $count)
};

(:~
 : Parse leadAnnotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-leadAnnotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-dataExcept($input, $state)
  return p:reduce($state, "leadAnnotatedDataExcept", $count)
};

(:~
 : Try parsing leadAnnotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-leadAnnotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-annotations($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-dataExcept($input, $state)
  return p:reduce($state, "leadAnnotatedDataExcept", $count)
};

(:~
 : Parse annotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-annotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-leadAnnotatedDataExcept($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:parse-followAnnotations($input, $state)
  return p:reduce($state, "annotatedDataExcept", $count)
};

(:~
 : Try parsing annotatedDataExcept.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-annotatedDataExcept($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-leadAnnotatedDataExcept($input, $state)
  let $state := p:lookahead1W(2, $input, $state)            (: EPSILON | separator :)
  let $state := p:try-followAnnotations($input, $state)
  return p:reduce($state, "annotatedDataExcept", $count)
};

(:~
 : Parse the 1st loop of production innerPattern (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-innerPattern-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | ',' | '[' | 'div' | 'include' | 'start' |
                                                               '|' | '}' :)
    return
      if ($state[$p:l1] != 8                                (: '&' :)
      and $state[$p:l1] != 14                               (: ',' :)
      and $state[$p:l1] != 41) then                         (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 41) then                      (: '|' :)
            let $state := p:shift(41, $input, $state)       (: '|' :)
            return $state
          else if ($state[$p:l1] = 14) then                 (: ',' :)
            let $state := p:shift(14, $input, $state)       (: ',' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(8, $input, $state)        (: '&' :)
            return $state
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:parse-innerParticle($input, $state)
        return p:parse-innerPattern-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production innerPattern (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-innerPattern-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               '&' | ')' | ',' | '[' | 'div' | 'include' | 'start' |
                                                               '|' | '}' :)
    return
      if ($state[$p:l1] != 8                                (: '&' :)
      and $state[$p:l1] != 14                               (: ',' :)
      and $state[$p:l1] != 41) then                         (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 41) then                      (: '|' :)
            let $state := p:shift(41, $input, $state)       (: '|' :)
            return $state
          else if ($state[$p:l1] = 14) then                 (: ',' :)
            let $state := p:shift(14, $input, $state)       (: ',' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(8, $input, $state)        (: '&' :)
            return $state
        let $state := p:lookahead1W(2, $input, $state)      (: EPSILON | separator :)
        let $state := p:try-innerParticle($input, $state)
        return p:try-innerPattern-1($input, $state)
};

(:~
 : Parse innerPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-innerPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(32, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: documentation :)
      let $state := p:lookahead2W(32, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 4                              (: 'string' :)
          or $state[$p:l1] = 37                             (: 'token' :)
          or $state[$p:l1] = 39) then                       (: 'token' :)
      let $state := p:lookahead2W(37, $input, $state)       (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '&' | ')' | '*' | '+' | ',' | '-' |
                                                               '>>' | '?' | '[' | 'div' | 'include' | 'start' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 211                            (: '[' identifier :)
          or $state[$p:lk] = 262                            (: documentation CName :)
          or $state[$p:lk] = 275                            (: '[' CName :)
          or $state[$p:lk] = 390                            (: documentation documentation :)
          or $state[$p:lk] = 1222                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2374                           (: documentation 'string' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2502                           (: documentation 'token' :)
          or $state[$p:lk] = 2515                           (: '[' 'token' :)
          or $state[$p:lk] = 2564                           (: CName '{' :)
          or $state[$p:lk] = 2597                           (: 'string' '{' :)
          or $state[$p:lk] = 2599) then                     (: 'token' '{' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-annotatedDataExcept($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 1)
            else
              p:memoize($backtrack, $state, -2, 1)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -1
     or $state[$p:lk] = 964                                 (: CName '-' :)
     or $state[$p:lk] = 997                                 (: 'string' '-' :)
     or $state[$p:lk] = 999) then                           (: 'token' '-' :)
      let $state := p:parse-annotatedDataExcept($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-innerParticle($input, $state)
      let $state := p:parse-innerPattern-1($input, $state)
      return $state
  return p:reduce($state, "innerPattern", $count)
};

(:~
 : Try parsing innerPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-innerPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(32, $input, $state)           (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: documentation :)
      let $state := p:lookahead2W(32, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'element' |
                                                               'empty' | 'external' | 'grammar' | 'list' | 'mixed' |
                                                               'notAllowed' | 'parent' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 4                              (: 'string' :)
          or $state[$p:l1] = 37                             (: 'token' :)
          or $state[$p:l1] = 39) then                       (: 'token' :)
      let $state := p:lookahead2W(37, $input, $state)       (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '&' | ')' | '*' | '+' | ',' | '-' |
                                                               '>>' | '?' | '[' | 'div' | 'include' | 'start' | '{' |
                                                               '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 211                            (: '[' identifier :)
          or $state[$p:lk] = 262                            (: documentation CName :)
          or $state[$p:lk] = 275                            (: '[' CName :)
          or $state[$p:lk] = 390                            (: documentation documentation :)
          or $state[$p:lk] = 1222                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2374                           (: documentation 'string' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2502                           (: documentation 'token' :)
          or $state[$p:lk] = 2515                           (: '[' 'token' :)
          or $state[$p:lk] = 2564                           (: CName '{' :)
          or $state[$p:lk] = 2597                           (: 'string' '{' :)
          or $state[$p:lk] = 2599) then                     (: 'token' '{' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-annotatedDataExcept($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 1)
            else
              p:memoize($backtrack, $state, -2, 1)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -1
     or $state[$p:lk] = 964                                 (: CName '-' :)
     or $state[$p:lk] = 997                                 (: 'string' '-' :)
     or $state[$p:lk] = 999) then                           (: 'token' '-' :)
      let $state := p:try-annotatedDataExcept($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-innerParticle($input, $state)
      let $state := p:try-innerPattern-1($input, $state)
      return $state
  return p:reduce($state, "innerPattern", $count)
};

(:~
 : Parse pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-innerPattern($input, $state)
  return p:reduce($state, "pattern", $count)
};

(:~
 : Try parsing pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:try-innerPattern($input, $state)
  return p:reduce($state, "pattern", $count)
};

(:~
 : Parse topLevelBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-topLevelBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:lookahead2W(27, $input, $state)       (: END | separator | '&' | '&=' | '*' | '+' | ',' | '=' |
                                                               '>>' | '?' | '[' | '|' | '|=' :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: CName :)
      let $state := p:lookahead2W(26, $input, $state)       (: END | separator | literalSegment | '&' | '*' | '+' |
                                                               ',' | '-' | '>>' | '?' | '[' | '{' | '|' :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: documentation :)
      let $state := p:lookahead2W(40, $input, $state)       (: separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'div' |
                                                               'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'list' | 'mixed' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '[' :)
      let $state := p:lookahead2W(42, $input, $state)       (: separator | identifier | CName | ']' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 198                            (: documentation identifier :)
          or $state[$p:lk] = 211                            (: '[' identifier :)
          or $state[$p:lk] = 275                            (: '[' CName :)
          or $state[$p:lk] = 390                            (: documentation documentation :)
          or $state[$p:lk] = 1222                           (: documentation '[' :)
          or $state[$p:lk] = 1299                           (: '[' ']' :)
          or $state[$p:lk] = 1363                           (: '[' 'attribute' :)
          or $state[$p:lk] = 1427                           (: '[' 'datatypes' :)
          or $state[$p:lk] = 1491                           (: '[' 'default' :)
          or $state[$p:lk] = 1555                           (: '[' 'div' :)
          or $state[$p:lk] = 1619                           (: '[' 'element' :)
          or $state[$p:lk] = 1683                           (: '[' 'empty' :)
          or $state[$p:lk] = 1747                           (: '[' 'external' :)
          or $state[$p:lk] = 1811                           (: '[' 'grammar' :)
          or $state[$p:lk] = 1875                           (: '[' 'include' :)
          or $state[$p:lk] = 1939                           (: '[' 'inherit' :)
          or $state[$p:lk] = 2003                           (: '[' 'list' :)
          or $state[$p:lk] = 2067                           (: '[' 'mixed' :)
          or $state[$p:lk] = 2131                           (: '[' 'namespace' :)
          or $state[$p:lk] = 2195                           (: '[' 'notAllowed' :)
          or $state[$p:lk] = 2259                           (: '[' 'parent' :)
          or $state[$p:lk] = 2323                           (: '[' 'start' :)
          or $state[$p:lk] = 2387                           (: '[' 'string' :)
          or $state[$p:lk] = 2451                           (: '[' 'text' :)
          or $state[$p:lk] = 2515) then                     (: '[' 'token' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-pattern($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -2
     or $state[$p:lk] = 1                                   (: END :)
     or $state[$p:lk] = 24                                  (: 'div' :)
     or $state[$p:lk] = 29                                  (: 'include' :)
     or $state[$p:lk] = 36                                  (: 'start' :)
     or $state[$p:lk] = 579                                 (: identifier '&=' :)
     or $state[$p:lk] = 1027                                (: identifier '=' :)
     or $state[$p:lk] = 1219                                (: identifier '[' :)
     or $state[$p:lk] = 1220                                (: CName '[' :)
     or $state[$p:lk] = 1542                                (: documentation 'div' :)
     or $state[$p:lk] = 1862                                (: documentation 'include' :)
     or $state[$p:lk] = 2310                                (: documentation 'start' :)
     or $state[$p:lk] = 2691) then                          (: identifier '|=' :)
      let $state := p:parse-grammar($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-pattern($input, $state)
      return $state
  return p:reduce($state, "topLevelBody", $count)
};

(:~
 : Parse datatypePrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-datatypePrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-identifierOrKeyword($input, $state)
  return p:reduce($state, "datatypePrefix", $count)
};

(:~
 : Parse the 1st loop of production literal (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-literal-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(50, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '&' | '(' | ')' | '*' | '+' | ',' |
                                                               '>>' | '?' | '[' | ']' | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' | '{' | '|' | '}' | '~' :)
    return
      if ($state[$p:l1] != 44) then                         (: '~' :)
        $state
      else
        let $state := p:shift(44, $input, $state)           (: '~' :)
        let $state := p:lookahead1W(4, $input, $state)      (: separator | literalSegment :)
        let $state := p:shift(7, $input, $state)            (: literalSegment :)
        return p:parse-literal-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production literal (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-literal-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(50, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '&' | '(' | ')' | '*' | '+' | ',' |
                                                               '>>' | '?' | '[' | ']' | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' | '{' | '|' | '}' | '~' :)
    return
      if ($state[$p:l1] != 44) then                         (: '~' :)
        $state
      else
        let $state := p:shift(44, $input, $state)           (: '~' :)
        let $state := p:lookahead1W(4, $input, $state)      (: separator | literalSegment :)
        let $state := p:shift(7, $input, $state)            (: literalSegment :)
        return p:try-literal-1($input, $state)
};

(:~
 : Parse literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(0, $input, $state)             (: literalSegment :)
  let $state := p:shift(7, $input, $state)                  (: literalSegment :)
  let $state := p:parse-literal-1($input, $state)
  return p:reduce($state, "literal", $count)
};

(:~
 : Try parsing literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(0, $input, $state)             (: literalSegment :)
  let $state := p:shift(7, $input, $state)                  (: literalSegment :)
  let $state := p:try-literal-1($input, $state)
  return p:reduce($state, "literal", $count)
};

(:~
 : Parse namespaceURILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-namespaceURILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: literalSegment | 'inherit' :)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: literalSegment :)
      let $state := p:parse-literal($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(30, $input, $state)             (: 'inherit' :)
      return $state
  return p:reduce($state, "namespaceURILiteral", $count)
};

(:~
 : Parse identifierOrKeyword.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-identifierOrKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(36, $input, $state)            (: identifier | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:shift(3, $input, $state)              (: identifier :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: 'attribute' :)
      let $state := p:shift(21, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: 'default' :)
      let $state := p:shift(23, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: 'datatypes' :)
      let $state := p:shift(22, $input, $state)             (: 'datatypes' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: 'div' :)
      let $state := p:shift(24, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: 'element' :)
      let $state := p:shift(25, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:shift(26, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:shift(27, $input, $state)             (: 'external' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: 'grammar' :)
      let $state := p:shift(28, $input, $state)             (: 'grammar' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state := p:shift(29, $input, $state)             (: 'include' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:shift(30, $input, $state)             (: 'inherit' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: 'list' :)
      let $state := p:shift(31, $input, $state)             (: 'list' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: 'mixed' :)
      let $state := p:shift(32, $input, $state)             (: 'mixed' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: 'namespace' :)
      let $state := p:shift(33, $input, $state)             (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:shift(34, $input, $state)             (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'parent' :)
      let $state := p:shift(35, $input, $state)             (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state := p:shift(36, $input, $state)             (: 'start' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:shift(37, $input, $state)             (: 'string' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:shift(38, $input, $state)             (: 'text' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(39, $input, $state)             (: 'token' :)
      return $state
  return p:reduce($state, "identifierOrKeyword", $count)
};

(:~
 : Try parsing identifierOrKeyword.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-identifierOrKeyword($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(36, $input, $state)            (: identifier | 'attribute' | 'datatypes' | 'default' |
                                                               'div' | 'element' | 'empty' | 'external' | 'grammar' |
                                                               'include' | 'inherit' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: identifier :)
      let $state := p:shift(3, $input, $state)              (: identifier :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: 'attribute' :)
      let $state := p:shift(21, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: 'default' :)
      let $state := p:shift(23, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: 'datatypes' :)
      let $state := p:shift(22, $input, $state)             (: 'datatypes' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: 'div' :)
      let $state := p:shift(24, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: 'element' :)
      let $state := p:shift(25, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'empty' :)
      let $state := p:shift(26, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'external' :)
      let $state := p:shift(27, $input, $state)             (: 'external' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: 'grammar' :)
      let $state := p:shift(28, $input, $state)             (: 'grammar' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'include' :)
      let $state := p:shift(29, $input, $state)             (: 'include' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: 'inherit' :)
      let $state := p:shift(30, $input, $state)             (: 'inherit' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: 'list' :)
      let $state := p:shift(31, $input, $state)             (: 'list' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: 'mixed' :)
      let $state := p:shift(32, $input, $state)             (: 'mixed' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: 'namespace' :)
      let $state := p:shift(33, $input, $state)             (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'notAllowed' :)
      let $state := p:shift(34, $input, $state)             (: 'notAllowed' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'parent' :)
      let $state := p:shift(35, $input, $state)             (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: 'start' :)
      let $state := p:shift(36, $input, $state)             (: 'start' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'string' :)
      let $state := p:shift(37, $input, $state)             (: 'string' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'text' :)
      let $state := p:shift(38, $input, $state)             (: 'text' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(39, $input, $state)             (: 'token' :)
      return $state
  return p:reduce($state, "identifierOrKeyword", $count)
};

(:~
 : Parse namespacePrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-namespacePrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-identifierOrKeyword($input, $state)
  return p:reduce($state, "namespacePrefix", $count)
};

(:~
 : Parse decl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-decl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 22) then                            (: 'datatypes' :)
      let $state := p:shift(22, $input, $state)             (: 'datatypes' :)
      let $state := p:lookahead1W(38, $input, $state)       (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
      let $state := p:parse-datatypePrefix($input, $state)
      let $state := p:lookahead1W(7, $input, $state)        (: separator | '=' :)
      let $state := p:shift(16, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-literal($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:l1] = 33) then                        (: 'namespace' :)
          let $state := p:shift(33, $input, $state)         (: 'namespace' :)
          let $state := p:lookahead1W(38, $input, $state)   (: separator | identifier | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'inherit' | 'list' | 'mixed' |
                                                               'namespace' | 'notAllowed' | 'parent' | 'start' |
                                                               'string' | 'text' | 'token' :)
          let $state := p:parse-namespacePrefix($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(23, $input, $state)         (: 'default' :)
          let $state := p:lookahead1W(8, $input, $state)    (: separator | 'namespace' :)
          let $state := p:shift(33, $input, $state)         (: 'namespace' :)
          let $state := p:lookahead1W(41, $input, $state)   (: separator | identifier | '=' | 'attribute' |
                                                               'datatypes' | 'default' | 'div' | 'element' | 'empty' |
                                                               'external' | 'grammar' | 'include' | 'inherit' | 'list' |
                                                               'mixed' | 'namespace' | 'notAllowed' | 'parent' |
                                                               'start' | 'string' | 'text' | 'token' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 16) then              (: '=' :)
              let $state := p:parse-namespacePrefix($input, $state)
              return $state
            else
              $state
          return $state
      let $state := p:lookahead1W(7, $input, $state)        (: separator | '=' :)
      let $state := p:shift(16, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(2, $input, $state)        (: EPSILON | separator :)
      let $state := p:parse-namespaceURILiteral($input, $state)
      return $state
  return p:reduce($state, "decl", $count)
};

(:~
 : Parse the 1st loop of production topLevel (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-topLevel-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(46, $input, $state)         (: END | separator | identifier | CName | documentation |
                                                               literalSegment | '(' | '[' | 'attribute' | 'datatypes' |
                                                               'default' | 'div' | 'element' | 'empty' | 'external' |
                                                               'grammar' | 'include' | 'list' | 'mixed' | 'namespace' |
                                                               'notAllowed' | 'parent' | 'start' | 'string' | 'text' |
                                                               'token' :)
    return
      if ($state[$p:l1] != 22                               (: 'datatypes' :)
      and $state[$p:l1] != 23                               (: 'default' :)
      and $state[$p:l1] != 33) then                         (: 'namespace' :)
        $state
      else
        let $state := p:parse-decl($input, $state)
        return p:parse-topLevel-1($input, $state)
};

(:~
 : Parse topLevel.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-topLevel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-topLevel-1($input, $state)
  let $state := p:parse-topLevelBody($input, $state)
  return p:reduce($state, "topLevel", $count)
};

(:~
 : Parse start symbol topLevel from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-topLevel($s as xs:string) as item()*
{
  let $state := p:parse-topLevel($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};
(: End :)
declare function p:parse($s as xs:string) as item()*
{
  p:parse-topLevel($s)
};

